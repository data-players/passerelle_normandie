{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst graphTypes = require('./graphTypes');\n\nconst types = require('./types');\n\nconst util = require('./util'); // constants\n\n\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING\n} = require('./constants');\n\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\nconst api = {};\nmodule.exports = api;\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\n\napi.fromRDF = async (dataset, {\n  useRdfType = false,\n  useNativeTypes = false,\n  rdfDirection = null\n}) => {\n  const defaultGraph = {};\n  const graphMap = {\n    '@default': defaultGraph\n  };\n  const referencedOnce = {};\n\n  for (const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = quad.graph.termType === 'DefaultGraph' ? '@default' : quad.graph.value;\n\n    if (!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n\n    if (name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {\n        '@id': name\n      };\n    }\n\n    const nodeMap = graphMap[name]; // get subject, predicate, object\n\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n\n    if (!(s in nodeMap)) {\n      nodeMap[s] = {\n        '@id': s\n      };\n    }\n\n    const node = nodeMap[s];\n    const objectIsNode = o.termType.endsWith('Node');\n\n    if (objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {\n        '@id': o.value\n      };\n    }\n\n    if (p === RDF_TYPE && !useRdfType && objectIsNode) {\n      util.addValue(node, '@type', o.value, {\n        propertyIsArray: true\n      });\n      continue;\n    }\n\n    const value = _RDFToObject(o, useNativeTypes, rdfDirection);\n\n    util.addValue(node, p, value, {\n      propertyIsArray: true\n    }); // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n\n    if (objectIsNode) {\n      if (o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n\n        if (!('usages' in object)) {\n          object.usages = [];\n        }\n\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if (o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n       // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n       if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n       const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n       if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        util.addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n       const value = _RDFToObject(o, useNativeTypes);\n      util.addValue(node, p, value, {propertyIsArray: true});\n       // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n  // convert linked lists to @list arrays\n\n\n  for (const name in graphMap) {\n    const graphObject = graphMap[name]; // no @lists to be converted, continue\n\n    if (!(RDF_NIL in graphObject)) {\n      continue;\n    } // iterate backwards through each RDF list\n\n\n    const nil = graphObject[RDF_NIL];\n\n    if (!nil.usages) {\n      continue;\n    }\n\n    for (let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = []; // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n\n      let nodeKeyCount = Object.keys(node).length;\n\n      while (property === RDF_REST && types.isObject(referencedOnce[node['@id']]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node['@type']) && node['@type'].length === 1 && node['@type'][0] === RDF_LIST)) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']); // get next node, moving backwards through list\n\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length; // if node is not a blank node, then list head found\n\n        if (!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      } // transform list into @list object\n\n\n      delete head['@id'];\n      head['@list'] = list.reverse();\n\n      for (const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n\n    delete nil.usages;\n  }\n\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n\n  for (const subject of subjects) {\n    const node = defaultGraph[subject];\n\n    if (subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n\n      for (const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject]; // only add full subjects to top-level\n\n        if (!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    } // only add full subjects to top-level\n\n\n    if (!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n\n  return result;\n};\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n *\n * @return the JSON-LD object.\n */\n\n\nfunction _RDFToObject(o, useNativeTypes, rdfDirection) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if (o.termType.endsWith('Node')) {\n    return {\n      '@id': o.value\n    };\n  } // convert literal to JSON-LD\n\n\n  const rval = {\n    '@value': o.value\n  }; // add language\n\n  if (o.language) {\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n\n    if (!type) {\n      type = XSD_STRING;\n    }\n\n    if (type === RDF_JSON_LITERAL) {\n      type = '@json';\n\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch (e) {\n        throw new JsonLdError('JSON literal could not be parsed.', 'jsonld.InvalidJsonLiteral', {\n          code: 'invalid JSON literal',\n          value: rval['@value'],\n          cause: e\n        });\n      }\n    } // use native types for certain xsd types\n\n\n    if (useNativeTypes) {\n      if (type === XSD_BOOLEAN) {\n        if (rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if (rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if (types.isNumeric(rval['@value'])) {\n        if (type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n\n          if (i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if (type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      } // do not add native type\n\n\n      if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if (rdfDirection === 'i18n-datatype' && type.startsWith('https://www.w3.org/ns/i18n#')) {\n      const [, language, direction] = type.split(/[#_]/);\n\n      if (language.length > 0) {\n        rval['@language'] = language;\n\n        if (!language.match(REGEX_BCP47)) {\n          console.warn(`@language must be valid BCP47: ${language}`);\n        }\n      }\n\n      rval['@direction'] = direction;\n    } else if (type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}","map":{"version":3,"sources":["/app/node_modules/jsonld/lib/fromRdf.js"],"names":["JsonLdError","require","graphTypes","types","util","RDF_LIST","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","REGEX_BCP47","api","module","exports","fromRDF","dataset","useRdfType","useNativeTypes","rdfDirection","defaultGraph","graphMap","referencedOnce","quad","name","graph","termType","value","nodeMap","s","subject","p","predicate","o","object","node","objectIsNode","endsWith","addValue","propertyIsArray","_RDFToObject","usages","push","property","graphObject","nil","usage","head","list","listNodes","nodeKeyCount","Object","keys","length","isObject","isArray","isBlankNode","reverse","listNode","result","subjects","sort","graphSubjects","graphSubject","isSubjectReference","rval","language","type","datatype","JSON","parse","e","code","cause","isNumeric","i","parseInt","toFixed","parseFloat","includes","startsWith","direction","split","match","console","warn"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst util = require('./util');\n\n// constants\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = async (\n  dataset,\n  {\n    useRdfType = false,\n    useNativeTypes = false,\n    rdfDirection = null\n  }\n) => {\n  const defaultGraph = {};\n  const graphMap = {'@default': defaultGraph};\n  const referencedOnce = {};\n\n  for(const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = (quad.graph.termType === 'DefaultGraph') ?\n      '@default' : quad.graph.value;\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n\n    const nodeMap = graphMap[name];\n\n    // get subject, predicate, object\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n\n    if(!(s in nodeMap)) {\n      nodeMap[s] = {'@id': s};\n    }\n    const node = nodeMap[s];\n\n    const objectIsNode = o.termType.endsWith('Node');\n    if(objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {'@id': o.value};\n    }\n\n    if(p === RDF_TYPE && !useRdfType && objectIsNode) {\n      util.addValue(node, '@type', o.value, {propertyIsArray: true});\n      continue;\n    }\n\n    const value = _RDFToObject(o, useNativeTypes, rdfDirection);\n    util.addValue(node, p, value, {propertyIsArray: true});\n\n    // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n    if(objectIsNode) {\n      if(o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n        if(!('usages' in object)) {\n          object.usages = [];\n        }\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if(o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n\n      // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n\n      if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n\n      const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n\n      if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        util.addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n\n      const value = _RDFToObject(o, useNativeTypes);\n      util.addValue(node, p, value, {propertyIsArray: true});\n\n      // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n\n  // convert linked lists to @list arrays\n  for(const name in graphMap) {\n    const graphObject = graphMap[name];\n\n    // no @lists to be converted, continue\n    if(!(RDF_NIL in graphObject)) {\n      continue;\n    }\n\n    // iterate backwards through each RDF list\n    const nil = graphObject[RDF_NIL];\n    if(!nil.usages) {\n      continue;\n    }\n    for(let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = [];\n\n      // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n      let nodeKeyCount = Object.keys(node).length;\n      while(property === RDF_REST &&\n        types.isObject(referencedOnce[node['@id']]) &&\n        types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 &&\n        types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 &&\n        (nodeKeyCount === 3 ||\n          (nodeKeyCount === 4 && types.isArray(node['@type']) &&\n          node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']);\n\n        // get next node, moving backwards through list\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length;\n\n        // if node is not a blank node, then list head found\n        if(!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      }\n\n      // transform list into @list object\n      delete head['@id'];\n      head['@list'] = list.reverse();\n      for(const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n\n    delete nil.usages;\n  }\n\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n  for(const subject of subjects) {\n    const node = defaultGraph[subject];\n    if(subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n      for(const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject];\n        // only add full subjects to top-level\n        if(!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    }\n    // only add full subjects to top-level\n    if(!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes, rdfDirection) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if(o.termType.endsWith('Node')) {\n    return {'@id': o.value};\n  }\n\n  // convert literal to JSON-LD\n  const rval = {'@value': o.value};\n\n  // add language\n  if(o.language) {\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n    if(!type) {\n      type = XSD_STRING;\n    }\n    if(type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch(e) {\n        throw new JsonLdError(\n          'JSON literal could not be parsed.',\n          'jsonld.InvalidJsonLiteral',\n          {code: 'invalid JSON literal', value: rval['@value'], cause: e});\n      }\n    }\n    // use native types for certain xsd types\n    if(useNativeTypes) {\n      if(type === XSD_BOOLEAN) {\n        if(rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if(rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if(types.isNumeric(rval['@value'])) {\n        if(type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n          if(i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if(type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if(![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if(rdfDirection === 'i18n-datatype' &&\n      type.startsWith('https://www.w3.org/ns/i18n#')) {\n      const [, language, direction] = type.split(/[#_]/);\n      if(language.length > 0) {\n        rval['@language'] = language;\n        if(!language.match(REGEX_BCP47)) {\n          console.warn(`@language must be valid BCP47: ${language}`);\n        }\n      }\n      rval['@direction'] = direction;\n    } else if(type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}\n"]},"metadata":{},"sourceType":"script"}