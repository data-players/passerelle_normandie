{"ast":null,"code":"/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2019 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = require('rdf-canonize');\n\nconst util = require('./util');\n\nconst ContextResolver = require('./ContextResolver');\n\nconst IdentifierIssuer = util.IdentifierIssuer;\n\nconst JsonLdError = require('./JsonLdError');\n\nconst LRU = require('lru-cache');\n\nconst NQuads = require('./NQuads');\n\nconst Rdfa = require('./Rdfa');\n\nconst {\n  expand: _expand\n} = require('./expand');\n\nconst {\n  flatten: _flatten\n} = require('./flatten');\n\nconst {\n  fromRDF: _fromRDF\n} = require('./fromRdf');\n\nconst {\n  toRDF: _toRDF\n} = require('./toRdf');\n\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault,\n  cleanupNull: _cleanupNull\n} = require('./frame');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = require('./types');\n\nconst {\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getInitialContext: _getInitialContext,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  compact: _compact,\n  compactIri: _compactIri\n} = require('./compact');\n\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = require('./nodeMap'); // determine if in-browser or using Node.js\n\n\nconst _nodejs = typeof process !== 'undefined' && process.versions && process.versions.node;\n\nconst _browser = !_nodejs && (typeof window !== 'undefined' || typeof self !== 'undefined');\n/* eslint-disable indent */\n// attaches jsonld API to the given object\n\n\nconst wrapper = function (jsonld) {\n  /** Registered RDF dataset parsers hashed by content-type. */\n  const _rdfParsers = {}; // resolved context cache\n  // TODO: consider basing max on context size rather than number\n\n  const RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\n\n  const _resolvedContextCache = new LRU({\n    max: RESOLVED_CONTEXT_CACHE_MAX_SIZE\n  });\n  /* Core API */\n\n  /**\n   * Performs JSON-LD compaction.\n   *\n   * @param input the JSON-LD input to compact.\n   * @param ctx the context to compact with.\n   * @param [options] options to use:\n   *          [base] the base IRI to use.\n   *          [compactArrays] true to compact arrays to single values when\n   *            appropriate, false not to (default: true).\n   *          [compactToRelative] true to compact IRIs to be relative to document\n   *            base, false to keep absolute (default: true)\n   *          [graph] true to always output a top-level graph (default: false).\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [documentLoader(url, options)] the document loader.\n   *          [expansionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [framing] true if compaction is occuring during a framing operation.\n   *          [compactionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the compacted output.\n   */\n\n\n  jsonld.compact = async function (input, ctx, options) {\n    if (arguments.length < 2) {\n      throw new TypeError('Could not compact, too few arguments.');\n    }\n\n    if (ctx === null) {\n      throw new JsonLdError('The compaction context must not be null.', 'jsonld.CompactError', {\n        code: 'invalid local context'\n      });\n    } // nothing to compact\n\n\n    if (input === null) {\n      return null;\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      compactArrays: true,\n      compactToRelative: true,\n      graph: false,\n      skipExpansion: false,\n      link: false,\n      issuer: new IdentifierIssuer('_:b'),\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    if (options.link) {\n      // force skip expansion when linking, \"link\" is not part of the public\n      // API, it should only be called from framing\n      options.skipExpansion = true;\n    }\n\n    if (!options.compactToRelative) {\n      delete options.base;\n    } // expand input\n\n\n    let expanded;\n\n    if (options.skipExpansion) {\n      expanded = input;\n    } else {\n      expanded = await jsonld.expand(input, options);\n    } // process context\n\n\n    const activeCtx = await jsonld.processContext(_getInitialContext(options), ctx, options); // do compaction\n\n    let compacted = await _compact({\n      activeCtx,\n      element: expanded,\n      options,\n      compactionMap: options.compactionMap\n    }); // perform clean up\n\n    if (options.compactArrays && !options.graph && _isArray(compacted)) {\n      if (compacted.length === 1) {\n        // simplify to a single item\n        compacted = compacted[0];\n      } else if (compacted.length === 0) {\n        // simplify to an empty object\n        compacted = {};\n      }\n    } else if (options.graph && _isObject(compacted)) {\n      // always use array if graph option is on\n      compacted = [compacted];\n    } // follow @context key\n\n\n    if (_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    } // build output context\n\n\n    ctx = util.clone(ctx);\n\n    if (!_isArray(ctx)) {\n      ctx = [ctx];\n    } // remove empty contexts\n\n\n    const tmp = ctx;\n    ctx = [];\n\n    for (let i = 0; i < tmp.length; ++i) {\n      if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n        ctx.push(tmp[i]);\n      }\n    } // remove array if only one context\n\n\n    const hasContext = ctx.length > 0;\n\n    if (ctx.length === 1) {\n      ctx = ctx[0];\n    } // add context and/or @graph\n\n\n    if (_isArray(compacted)) {\n      // use '@graph' keyword\n      const graphAlias = _compactIri({\n        activeCtx,\n        iri: '@graph',\n        relativeTo: {\n          vocab: true\n        }\n      });\n\n      const graph = compacted;\n      compacted = {};\n\n      if (hasContext) {\n        compacted['@context'] = ctx;\n      }\n\n      compacted[graphAlias] = graph;\n    } else if (_isObject(compacted) && hasContext) {\n      // reorder keys so @context is first\n      const graph = compacted;\n      compacted = {\n        '@context': ctx\n      };\n\n      for (const key in graph) {\n        compacted[key] = graph[key];\n      }\n    }\n\n    return compacted;\n  };\n  /**\n   * Performs JSON-LD expansion.\n   *\n   * @param input the JSON-LD input to expand.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n   *            false not to, defaults to false.\n   *          [documentLoader(url, options)] the document loader.\n   *          [expansionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the expanded output.\n   */\n\n\n  jsonld.expand = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not expand, too few arguments.');\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      keepFreeFloatingNodes: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    if (options.expansionMap === false) {\n      options.expansionMap = undefined;\n    } // build set of objects that may have @contexts to resolve\n\n\n    const toResolve = {}; // build set of contexts to process prior to expansion\n\n    const contextsToProcess = []; // if an `expandContext` has been given ensure it gets resolved\n\n    if ('expandContext' in options) {\n      const expandContext = util.clone(options.expandContext);\n\n      if (_isObject(expandContext) && '@context' in expandContext) {\n        toResolve.expandContext = expandContext;\n      } else {\n        toResolve.expandContext = {\n          '@context': expandContext\n        };\n      }\n\n      contextsToProcess.push(toResolve.expandContext);\n    } // if input is a string, attempt to dereference remote document\n\n\n    let defaultBase;\n\n    if (!_isString(input)) {\n      // input is not a URL, do not need to retrieve it first\n      toResolve.input = util.clone(input);\n    } else {\n      // load remote doc\n      const remoteDoc = await jsonld.get(input, options);\n      defaultBase = remoteDoc.documentUrl;\n      toResolve.input = remoteDoc.document;\n\n      if (remoteDoc.contextUrl) {\n        // context included in HTTP link header and must be resolved\n        toResolve.remoteContext = {\n          '@context': remoteDoc.contextUrl\n        };\n        contextsToProcess.push(toResolve.remoteContext);\n      }\n    } // set default base\n\n\n    if (!('base' in options)) {\n      options.base = defaultBase || '';\n    } // process any additional contexts\n\n\n    let activeCtx = _getInitialContext(options);\n\n    for (const localCtx of contextsToProcess) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx,\n        options\n      });\n    } // expand resolved input\n\n\n    let expanded = await _expand({\n      activeCtx,\n      element: toResolve.input,\n      options,\n      expansionMap: options.expansionMap\n    }); // optimize away @graph with no other properties\n\n    if (_isObject(expanded) && '@graph' in expanded && Object.keys(expanded).length === 1) {\n      expanded = expanded['@graph'];\n    } else if (expanded === null) {\n      expanded = [];\n    } // normalize to an array\n\n\n    if (!_isArray(expanded)) {\n      expanded = [expanded];\n    }\n\n    return expanded;\n  };\n  /**\n   * Performs JSON-LD flattening.\n   *\n   * @param input the JSON-LD to flatten.\n   * @param ctx the context to use to compact the flattened output, or null.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the flattened output.\n   */\n\n\n  jsonld.flatten = async function (input, ctx, options) {\n    if (arguments.length < 1) {\n      return new TypeError('Could not flatten, too few arguments.');\n    }\n\n    if (typeof ctx === 'function') {\n      ctx = null;\n    } else {\n      ctx = ctx || null;\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    }); // expand input\n\n    const expanded = await jsonld.expand(input, options); // do flattening\n\n    const flattened = _flatten(expanded);\n\n    if (ctx === null) {\n      // no compaction required\n      return flattened;\n    } // compact result (force @graph option to true, skip expansion)\n\n\n    options.graph = true;\n    options.skipExpansion = true;\n    const compacted = await jsonld.compact(flattened, ctx, options);\n    return compacted;\n  };\n  /**\n   * Performs JSON-LD framing.\n   *\n   * @param input the JSON-LD input to frame.\n   * @param frame the JSON-LD frame to use.\n   * @param [options] the framing options.\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n   *            (default: '@last').\n   *          [explicit] default @explicit flag (default: false).\n   *          [requireAll] default @requireAll flag (default: true).\n   *          [omitDefault] default @omitDefault flag (default: false).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the framed output.\n   */\n\n\n  jsonld.frame = async function (input, frame, options) {\n    if (arguments.length < 2) {\n      throw new TypeError('Could not frame, too few arguments.');\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      embed: '@once',\n      explicit: false,\n      requireAll: false,\n      omitDefault: false,\n      bnodesToClear: [],\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    }); // if frame is a string, attempt to dereference remote document\n\n    if (_isString(frame)) {\n      // load remote doc\n      const remoteDoc = await jsonld.get(frame, options);\n      frame = remoteDoc.document;\n\n      if (remoteDoc.contextUrl) {\n        // inject link header @context into frame\n        let ctx = frame['@context'];\n\n        if (!ctx) {\n          ctx = remoteDoc.contextUrl;\n        } else if (_isArray(ctx)) {\n          ctx.push(remoteDoc.contextUrl);\n        } else {\n          ctx = [ctx, remoteDoc.contextUrl];\n        }\n\n        frame['@context'] = ctx;\n      }\n    }\n\n    const frameContext = frame ? frame['@context'] || {} : {}; // process context\n\n    const activeCtx = await jsonld.processContext(_getInitialContext(options), frameContext, options); // mode specific defaults\n\n    if (!options.hasOwnProperty('omitGraph')) {\n      options.omitGraph = _processingMode(activeCtx, 1.1);\n    }\n\n    if (!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {\n      options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);\n    } // expand input\n\n\n    const expanded = await jsonld.expand(input, options); // expand frame\n\n    const opts = { ...options\n    };\n    opts.isFrame = true;\n    opts.keepFreeFloatingNodes = true;\n    const expandedFrame = await jsonld.expand(frame, opts); // if the unexpanded frame includes a key expanding to @graph, frame the\n    // default graph, otherwise, the merged graph\n\n    const frameKeys = Object.keys(frame).map(key => _expandIri(activeCtx, key, {\n      vocab: true\n    }));\n    opts.merged = !frameKeys.includes('@graph');\n    opts.is11 = _processingMode(activeCtx, 1.1); // do framing\n\n    const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n    opts.graph = !options.omitGraph;\n    opts.skipExpansion = true;\n    opts.link = {};\n    opts.framing = true;\n    let compacted = await jsonld.compact(framed, frameContext, opts); // replace @null with null, compacting arrays\n\n    opts.link = {};\n    compacted = _cleanupNull(compacted, opts);\n    return compacted;\n  };\n  /**\n   * **Experimental**\n   *\n   * Links a JSON-LD document's nodes in memory.\n   *\n   * @param input the JSON-LD document to link.\n   * @param [ctx] the JSON-LD context to apply.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the linked output.\n   */\n\n\n  jsonld.link = async function (input, ctx, options) {\n    // API matches running frame with a wildcard frame and embed: '@link'\n    // get arguments\n    const frame = {};\n\n    if (ctx) {\n      frame['@context'] = ctx;\n    }\n\n    frame['@embed'] = '@link';\n    return jsonld.frame(input, frame, options);\n  };\n  /**\n   * Performs RDF dataset normalization on the given input. The input is JSON-LD\n   * unless the 'inputFormat' option is used. The output is an RDF dataset\n   * unless the 'format' option is used.\n   *\n   * @param input the input to normalize as JSON-LD or as a format specified by\n   *          the 'inputFormat' option.\n   * @param [options] the options to use:\n   *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n   *            `URGNA2012` (default: `URDNA2015`).\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [inputFormat] the format if input is not JSON-LD:\n   *            'application/n-quads' for N-Quads.\n   *          [format] the format if output is a string:\n   *            'application/n-quads' for N-Quads.\n   *          [documentLoader(url, options)] the document loader.\n   *          [useNative] true to use a native canonize algorithm\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the normalized output.\n   */\n\n\n  jsonld.normalize = jsonld.canonize = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not canonize, too few arguments.');\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      algorithm: 'URDNA2015',\n      skipExpansion: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    if ('inputFormat' in options) {\n      if (options.inputFormat !== 'application/n-quads' && options.inputFormat !== 'application/nquads') {\n        throw new JsonLdError('Unknown canonicalization input format.', 'jsonld.CanonizeError');\n      } // TODO: `await` for async parsers\n\n\n      const parsedInput = NQuads.parse(input); // do canonicalization\n\n      return canonize.canonize(parsedInput, options);\n    } // convert to RDF dataset then do normalization\n\n\n    const opts = { ...options\n    };\n    delete opts.format;\n    opts.produceGeneralizedRdf = false;\n    const dataset = await jsonld.toRDF(input, opts); // do canonicalization\n\n    return canonize.canonize(dataset, options);\n  };\n  /**\n   * Converts an RDF dataset to JSON-LD.\n   *\n   * @param dataset a serialized string of RDF in a format specified by the\n   *          format option or an RDF dataset to convert.\n   * @param [options] the options to use:\n   *          [format] the format if dataset param must first be parsed:\n   *            'application/n-quads' for N-Quads (default).\n   *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n   *          [useRdfType] true to use rdf:type, false to use @type\n   *            (default: false).\n   *          [useNativeTypes] true to convert XSD types into native types\n   *            (boolean, integer, double), false not to (default: false).\n   *\n   * @return a Promise that resolves to the JSON-LD document.\n   */\n\n\n  jsonld.fromRDF = async function (dataset, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not convert from RDF, too few arguments.');\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      format: _isString(dataset) ? 'application/n-quads' : undefined\n    });\n    const {\n      format\n    } = options;\n    let {\n      rdfParser\n    } = options; // handle special format\n\n    if (format) {\n      // check supported formats\n      rdfParser = rdfParser || _rdfParsers[format];\n\n      if (!rdfParser) {\n        throw new JsonLdError('Unknown input format.', 'jsonld.UnknownFormat', {\n          format\n        });\n      }\n    } else {\n      // no-op parser, assume dataset already parsed\n      rdfParser = () => dataset;\n    } // rdfParser must be synchronous or return a promise, no callback support\n\n\n    const parsedDataset = await rdfParser(dataset);\n    return _fromRDF(parsedDataset, options);\n  };\n  /**\n   * Outputs the RDF dataset found in the given JSON-LD object.\n   *\n   * @param input the JSON-LD input.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [format] the format to use to output a string:\n   *            'application/n-quads' for N-Quads.\n   *          [produceGeneralizedRdf] true to output generalized RDF, false\n   *            to produce only standard RDF (default: false).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the RDF dataset.\n   */\n\n\n  jsonld.toRDF = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not convert to RDF, too few arguments.');\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      skipExpansion: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    }); // TODO: support toRDF custom map?\n\n    let expanded;\n\n    if (options.skipExpansion) {\n      expanded = input;\n    } else {\n      // expand input\n      expanded = await jsonld.expand(input, options);\n    } // output RDF dataset\n\n\n    const dataset = _toRDF(expanded, options);\n\n    if (options.format) {\n      if (options.format === 'application/n-quads' || options.format === 'application/nquads') {\n        return await NQuads.serialize(dataset);\n      }\n\n      throw new JsonLdError('Unknown output format.', 'jsonld.UnknownFormat', {\n        format: options.format\n      });\n    }\n\n    return dataset;\n  };\n  /**\n   * **Experimental**\n   *\n   * Recursively flattens the nodes in the given JSON-LD input into a merged\n   * map of node ID => node. All graphs will be merged into the default graph.\n   *\n   * @param input the JSON-LD input.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the merged node map.\n   */\n\n\n  jsonld.createNodeMap = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not create node map, too few arguments.');\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    }); // expand input\n\n    const expanded = await jsonld.expand(input, options);\n    return _createMergedNodeMap(expanded, options);\n  };\n  /**\n   * **Experimental**\n   *\n   * Merges two or more JSON-LD documents into a single flattened document.\n   *\n   * @param docs the JSON-LD documents to merge together.\n   * @param ctx the context to use to compact the merged result, or null.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n   *          [mergeNodes] true to merge properties for nodes with the same ID,\n   *            false to ignore new properties for nodes with the same ID once\n   *            the ID has been defined; note that this may not prevent merging\n   *            new properties where a node is in the `object` position\n   *            (default: true).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the merged output.\n   */\n\n\n  jsonld.merge = async function (docs, ctx, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not merge, too few arguments.');\n    }\n\n    if (!_isArray(docs)) {\n      throw new TypeError('Could not merge, \"docs\" must be an array.');\n    }\n\n    if (typeof ctx === 'function') {\n      ctx = null;\n    } else {\n      ctx = ctx || null;\n    } // set default options\n\n\n    options = _setDefaults(options, {\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    }); // expand all documents\n\n    const expanded = await Promise.all(docs.map(doc => {\n      const opts = { ...options\n      };\n      return jsonld.expand(doc, opts);\n    }));\n    let mergeNodes = true;\n\n    if ('mergeNodes' in options) {\n      mergeNodes = options.mergeNodes;\n    }\n\n    const issuer = options.issuer || new IdentifierIssuer('_:b');\n    const graphs = {\n      '@default': {}\n    };\n\n    for (let i = 0; i < expanded.length; ++i) {\n      // uniquely relabel blank nodes\n      const doc = util.relabelBlankNodes(expanded[i], {\n        issuer: new IdentifierIssuer('_:b' + i + '-')\n      }); // add nodes to the shared node map graphs if merging nodes, to a\n      // separate graph set if not\n\n      const _graphs = mergeNodes || i === 0 ? graphs : {\n        '@default': {}\n      };\n\n      _createNodeMap(doc, _graphs, '@default', issuer);\n\n      if (_graphs !== graphs) {\n        // merge document graphs but don't merge existing nodes\n        for (const graphName in _graphs) {\n          const _nodeMap = _graphs[graphName];\n\n          if (!(graphName in graphs)) {\n            graphs[graphName] = _nodeMap;\n            continue;\n          }\n\n          const nodeMap = graphs[graphName];\n\n          for (const key in _nodeMap) {\n            if (!(key in nodeMap)) {\n              nodeMap[key] = _nodeMap[key];\n            }\n          }\n        }\n      }\n    } // add all non-default graphs to default graph\n\n\n    const defaultGraph = _mergeNodeMaps(graphs); // produce flattened output\n\n\n    const flattened = [];\n    const keys = Object.keys(defaultGraph).sort();\n\n    for (let ki = 0; ki < keys.length; ++ki) {\n      const node = defaultGraph[keys[ki]]; // only add full subjects to top-level\n\n      if (!_isSubjectReference(node)) {\n        flattened.push(node);\n      }\n    }\n\n    if (ctx === null) {\n      return flattened;\n    } // compact result (force @graph option to true, skip expansion)\n\n\n    options.graph = true;\n    options.skipExpansion = true;\n    const compacted = await jsonld.compact(flattened, ctx, options);\n    return compacted;\n  };\n  /**\n   * The default document loader for external documents.\n   *\n   * @param url the URL to load.\n   *\n   * @return a promise that resolves to the remote document.\n   */\n\n\n  Object.defineProperty(jsonld, 'documentLoader', {\n    get: () => jsonld._documentLoader,\n    set: v => jsonld._documentLoader = v\n  }); // default document loader not implemented\n\n  jsonld.documentLoader = async url => {\n    throw new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {\n      code: 'loading document failed',\n      url\n    });\n  };\n  /**\n   * Gets a remote JSON-LD document using the default document loader or\n   * one given in the passed options.\n   *\n   * @param url the URL to fetch.\n   * @param [options] the options to use:\n   *          [documentLoader] the document loader to use.\n   *\n   * @return a Promise that resolves to the retrieved remote document.\n   */\n\n\n  jsonld.get = async function (url, options) {\n    let load;\n\n    if (typeof options.documentLoader === 'function') {\n      load = options.documentLoader;\n    } else {\n      load = jsonld.documentLoader;\n    }\n\n    const remoteDoc = await load(url);\n\n    try {\n      if (!remoteDoc.document) {\n        throw new JsonLdError('No remote document found at the given URL.', 'jsonld.NullRemoteDocument');\n      }\n\n      if (_isString(remoteDoc.document)) {\n        remoteDoc.document = JSON.parse(remoteDoc.document);\n      }\n    } catch (e) {\n      throw new JsonLdError('Could not retrieve a JSON-LD document from the URL.', 'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n    }\n\n    return remoteDoc;\n  };\n  /**\n   * Processes a local context, resolving any URLs as necessary, and returns a\n   * new active context.\n   *\n   * @param activeCtx the current active context.\n   * @param localCtx the local context to process.\n   * @param [options] the options to use:\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the new active context.\n   */\n\n\n  jsonld.processContext = async function (activeCtx, localCtx, options) {\n    // set default options\n    options = _setDefaults(options, {\n      base: '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    }); // return initial context early for null context\n\n    if (localCtx === null) {\n      return _getInitialContext(options);\n    } // get URLs in localCtx\n\n\n    localCtx = util.clone(localCtx);\n\n    if (!(_isObject(localCtx) && '@context' in localCtx)) {\n      localCtx = {\n        '@context': localCtx\n      };\n    }\n\n    return _processContext({\n      activeCtx,\n      localCtx,\n      options\n    });\n  }; // backwards compatibility\n\n\n  jsonld.getContextValue = require('./context').getContextValue;\n  /**\n   * Document loaders.\n   */\n\n  jsonld.documentLoaders = {};\n  jsonld.documentLoaders.node = require('./documentLoaders/node');\n  jsonld.documentLoaders.xhr = require('./documentLoaders/xhr');\n  /**\n   * Assigns the default document loader for external document URLs to a built-in\n   * default. Supported types currently include: 'xhr' and 'node'.\n   *\n   * @param type the type to set.\n   * @param [params] the parameters required to use the document loader.\n   */\n\n  jsonld.useDocumentLoader = function (type) {\n    if (!(type in jsonld.documentLoaders)) {\n      throw new JsonLdError('Unknown document loader type: \"' + type + '\"', 'jsonld.UnknownDocumentLoader', {\n        type\n      });\n    } // set document loader\n\n\n    jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));\n  };\n  /**\n   * Registers an RDF dataset parser by content-type, for use with\n   * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n   * a string of input. An RDF dataset parser can be synchronous or\n   * asynchronous (by returning a promise).\n   *\n   * @param contentType the content-type for the parser.\n   * @param parser(input) the parser function (takes a string as a parameter\n   *          and either returns an RDF dataset or a Promise that resolves to one.\n   */\n\n\n  jsonld.registerRDFParser = function (contentType, parser) {\n    _rdfParsers[contentType] = parser;\n  };\n  /**\n   * Unregisters an RDF dataset parser by content-type.\n   *\n   * @param contentType the content-type for the parser.\n   */\n\n\n  jsonld.unregisterRDFParser = function (contentType) {\n    delete _rdfParsers[contentType];\n  }; // register the N-Quads RDF parser\n\n\n  jsonld.registerRDFParser('application/n-quads', NQuads.parse);\n  jsonld.registerRDFParser('application/nquads', NQuads.parse); // register the RDFa API RDF parser\n\n  jsonld.registerRDFParser('rdfa-api', Rdfa.parse);\n  /* URL API */\n\n  jsonld.url = require('./url');\n  /* Utility API */\n\n  jsonld.util = util; // backwards compatibility\n\n  Object.assign(jsonld, util); // reexpose API as jsonld.promises for backwards compatability\n\n  jsonld.promises = jsonld; // backwards compatibility\n\n  jsonld.RequestQueue = require('./RequestQueue');\n  /* WebIDL API */\n\n  jsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld); // setup browser global JsonLdProcessor\n\n  if (_browser && typeof global.JsonLdProcessor === 'undefined') {\n    Object.defineProperty(global, 'JsonLdProcessor', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: jsonld.JsonLdProcessor\n    });\n  } // set platform-specific defaults/APIs\n\n\n  if (_nodejs) {\n    // use node document loader by default\n    jsonld.useDocumentLoader('node');\n  } else if (typeof XMLHttpRequest !== 'undefined') {\n    // use xhr document loader by default\n    jsonld.useDocumentLoader('xhr');\n  }\n\n  function _setDefaults(options, {\n    documentLoader = jsonld.documentLoader,\n    ...defaults\n  }) {\n    return Object.assign({}, {\n      documentLoader\n    }, defaults, options);\n  } // end of jsonld API `wrapper` factory\n\n\n  return jsonld;\n}; // external APIs:\n// used to generate a new jsonld API instance\n\n\nconst factory = function () {\n  return wrapper(function () {\n    return factory();\n  });\n}; // wrap the main jsonld API instance\n\n\nwrapper(factory); // export API\n\nmodule.exports = factory;","map":{"version":3,"sources":["/app/node_modules/jsonld/lib/jsonld.js"],"names":["canonize","require","util","ContextResolver","IdentifierIssuer","JsonLdError","LRU","NQuads","Rdfa","expand","_expand","flatten","_flatten","fromRDF","_fromRDF","toRDF","_toRDF","frameMergedOrDefault","_frameMergedOrDefault","cleanupNull","_cleanupNull","isArray","_isArray","isObject","_isObject","isString","_isString","isSubjectReference","_isSubjectReference","expandIri","_expandIri","getInitialContext","_getInitialContext","process","_processContext","processingMode","_processingMode","compact","_compact","compactIri","_compactIri","createNodeMap","_createNodeMap","createMergedNodeMap","_createMergedNodeMap","mergeNodeMaps","_mergeNodeMaps","_nodejs","versions","node","_browser","window","self","wrapper","jsonld","_rdfParsers","RESOLVED_CONTEXT_CACHE_MAX_SIZE","_resolvedContextCache","max","input","ctx","options","arguments","length","TypeError","code","_setDefaults","base","compactArrays","compactToRelative","graph","skipExpansion","link","issuer","contextResolver","sharedCache","expanded","activeCtx","processContext","compacted","element","compactionMap","clone","tmp","i","Object","keys","push","hasContext","graphAlias","iri","relativeTo","vocab","key","keepFreeFloatingNodes","expansionMap","undefined","toResolve","contextsToProcess","expandContext","defaultBase","remoteDoc","get","documentUrl","document","contextUrl","remoteContext","localCtx","flattened","frame","embed","explicit","requireAll","omitDefault","bnodesToClear","frameContext","hasOwnProperty","omitGraph","pruneBlankNodeIdentifiers","opts","isFrame","expandedFrame","frameKeys","map","merged","includes","is11","framed","framing","normalize","algorithm","inputFormat","parsedInput","parse","format","produceGeneralizedRdf","dataset","rdfParser","parsedDataset","serialize","merge","docs","Promise","all","doc","mergeNodes","graphs","relabelBlankNodes","_graphs","graphName","_nodeMap","nodeMap","defaultGraph","sort","ki","defineProperty","_documentLoader","set","v","documentLoader","url","load","JSON","e","cause","getContextValue","documentLoaders","xhr","useDocumentLoader","type","apply","Array","prototype","slice","call","registerRDFParser","contentType","parser","unregisterRDFParser","assign","promises","RequestQueue","JsonLdProcessor","global","writable","enumerable","configurable","value","XMLHttpRequest","defaults","factory","module","exports"],"mappings":"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","sourcesContent":["/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2019 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = require('rdf-canonize');\nconst util = require('./util');\nconst ContextResolver = require('./ContextResolver');\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\nconst LRU = require('lru-cache');\nconst NQuads = require('./NQuads');\nconst Rdfa = require('./Rdfa');\n\nconst {expand: _expand} = require('./expand');\nconst {flatten: _flatten} = require('./flatten');\nconst {fromRDF: _fromRDF} = require('./fromRdf');\nconst {toRDF: _toRDF} = require('./toRdf');\n\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault,\n  cleanupNull: _cleanupNull\n} = require('./frame');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = require('./types');\n\nconst {\n  isSubjectReference: _isSubjectReference,\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getInitialContext: _getInitialContext,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  compact: _compact,\n  compactIri: _compactIri\n} = require('./compact');\n\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = require('./nodeMap');\n\n// determine if in-browser or using Node.js\nconst _nodejs = (\n  typeof process !== 'undefined' && process.versions && process.versions.node);\nconst _browser = !_nodejs &&\n  (typeof window !== 'undefined' || typeof self !== 'undefined');\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function(jsonld) {\n\n/** Registered RDF dataset parsers hashed by content-type. */\nconst _rdfParsers = {};\n\n// resolved context cache\n// TODO: consider basing max on context size rather than number\nconst RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\nconst _resolvedContextCache = new LRU({max: RESOLVED_CONTEXT_CACHE_MAX_SIZE});\n\n/* Core API */\n\n/**\n * Performs JSON-LD compaction.\n *\n * @param input the JSON-LD input to compact.\n * @param ctx the context to compact with.\n * @param [options] options to use:\n *          [base] the base IRI to use.\n *          [compactArrays] true to compact arrays to single values when\n *            appropriate, false not to (default: true).\n *          [compactToRelative] true to compact IRIs to be relative to document\n *            base, false to keep absolute (default: true)\n *          [graph] true to always output a top-level graph (default: false).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [framing] true if compaction is occuring during a framing operation.\n *          [compactionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the compacted output.\n */\njsonld.compact = async function(input, ctx, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not compact, too few arguments.');\n  }\n\n  if(ctx === null) {\n    throw new JsonLdError(\n      'The compaction context must not be null.',\n      'jsonld.CompactError', {code: 'invalid local context'});\n  }\n\n  // nothing to compact\n  if(input === null) {\n    return null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    compactArrays: true,\n    compactToRelative: true,\n    graph: false,\n    skipExpansion: false,\n    link: false,\n    issuer: new IdentifierIssuer('_:b'),\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.link) {\n    // force skip expansion when linking, \"link\" is not part of the public\n    // API, it should only be called from framing\n    options.skipExpansion = true;\n  }\n  if(!options.compactToRelative) {\n    delete options.base;\n  }\n\n  // expand input\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), ctx, options);\n\n  // do compaction\n  let compacted = await _compact({\n    activeCtx,\n    element: expanded,\n    options,\n    compactionMap: options.compactionMap\n  });\n\n  // perform clean up\n  if(options.compactArrays && !options.graph && _isArray(compacted)) {\n    if(compacted.length === 1) {\n      // simplify to a single item\n      compacted = compacted[0];\n    } else if(compacted.length === 0) {\n      // simplify to an empty object\n      compacted = {};\n    }\n  } else if(options.graph && _isObject(compacted)) {\n    // always use array if graph option is on\n    compacted = [compacted];\n  }\n\n  // follow @context key\n  if(_isObject(ctx) && '@context' in ctx) {\n    ctx = ctx['@context'];\n  }\n\n  // build output context\n  ctx = util.clone(ctx);\n  if(!_isArray(ctx)) {\n    ctx = [ctx];\n  }\n  // remove empty contexts\n  const tmp = ctx;\n  ctx = [];\n  for(let i = 0; i < tmp.length; ++i) {\n    if(!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n      ctx.push(tmp[i]);\n    }\n  }\n\n  // remove array if only one context\n  const hasContext = (ctx.length > 0);\n  if(ctx.length === 1) {\n    ctx = ctx[0];\n  }\n\n  // add context and/or @graph\n  if(_isArray(compacted)) {\n    // use '@graph' keyword\n    const graphAlias = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    const graph = compacted;\n    compacted = {};\n    if(hasContext) {\n      compacted['@context'] = ctx;\n    }\n    compacted[graphAlias] = graph;\n  } else if(_isObject(compacted) && hasContext) {\n    // reorder keys so @context is first\n    const graph = compacted;\n    compacted = {'@context': ctx};\n    for(const key in graph) {\n      compacted[key] = graph[key];\n    }\n  }\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD expansion.\n *\n * @param input the JSON-LD input to expand.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n *            false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the expanded output.\n */\njsonld.expand = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not expand, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    keepFreeFloatingNodes: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.expansionMap === false) {\n    options.expansionMap = undefined;\n  }\n\n  // build set of objects that may have @contexts to resolve\n  const toResolve = {};\n\n  // build set of contexts to process prior to expansion\n  const contextsToProcess = [];\n\n  // if an `expandContext` has been given ensure it gets resolved\n  if('expandContext' in options) {\n    const expandContext = util.clone(options.expandContext);\n    if(_isObject(expandContext) && '@context' in expandContext) {\n      toResolve.expandContext = expandContext;\n    } else {\n      toResolve.expandContext = {'@context': expandContext};\n    }\n    contextsToProcess.push(toResolve.expandContext);\n  }\n\n  // if input is a string, attempt to dereference remote document\n  let defaultBase;\n  if(!_isString(input)) {\n    // input is not a URL, do not need to retrieve it first\n    toResolve.input = util.clone(input);\n  } else {\n    // load remote doc\n    const remoteDoc = await jsonld.get(input, options);\n    defaultBase = remoteDoc.documentUrl;\n    toResolve.input = remoteDoc.document;\n    if(remoteDoc.contextUrl) {\n      // context included in HTTP link header and must be resolved\n      toResolve.remoteContext = {'@context': remoteDoc.contextUrl};\n      contextsToProcess.push(toResolve.remoteContext);\n    }\n  }\n\n  // set default base\n  if(!('base' in options)) {\n    options.base = defaultBase || '';\n  }\n\n  // process any additional contexts\n  let activeCtx = _getInitialContext(options);\n  for(const localCtx of contextsToProcess) {\n    activeCtx = await _processContext({activeCtx, localCtx, options});\n  }\n\n  // expand resolved input\n  let expanded = await _expand({\n    activeCtx,\n    element: toResolve.input,\n    options,\n    expansionMap: options.expansionMap\n  });\n\n  // optimize away @graph with no other properties\n  if(_isObject(expanded) && ('@graph' in expanded) &&\n    Object.keys(expanded).length === 1) {\n    expanded = expanded['@graph'];\n  } else if(expanded === null) {\n    expanded = [];\n  }\n\n  // normalize to an array\n  if(!_isArray(expanded)) {\n    expanded = [expanded];\n  }\n\n  return expanded;\n};\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the JSON-LD to flatten.\n * @param ctx the context to use to compact the flattened output, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the flattened output.\n */\njsonld.flatten = async function(input, ctx, options) {\n  if(arguments.length < 1) {\n    return new TypeError('Could not flatten, too few arguments.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // do flattening\n  const flattened = _flatten(expanded);\n\n  if(ctx === null) {\n    // no compaction required\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD framing.\n *\n * @param input the JSON-LD input to frame.\n * @param frame the JSON-LD frame to use.\n * @param [options] the framing options.\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n *            (default: '@last').\n *          [explicit] default @explicit flag (default: false).\n *          [requireAll] default @requireAll flag (default: true).\n *          [omitDefault] default @omitDefault flag (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the framed output.\n */\njsonld.frame = async function(input, frame, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not frame, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    embed: '@once',\n    explicit: false,\n    requireAll: false,\n    omitDefault: false,\n    bnodesToClear: [],\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // if frame is a string, attempt to dereference remote document\n  if(_isString(frame)) {\n    // load remote doc\n    const remoteDoc = await jsonld.get(frame, options);\n    frame = remoteDoc.document;\n\n    if(remoteDoc.contextUrl) {\n      // inject link header @context into frame\n      let ctx = frame['@context'];\n      if(!ctx) {\n        ctx = remoteDoc.contextUrl;\n      } else if(_isArray(ctx)) {\n        ctx.push(remoteDoc.contextUrl);\n      } else {\n        ctx = [ctx, remoteDoc.contextUrl];\n      }\n      frame['@context'] = ctx;\n    }\n  }\n\n  const frameContext = frame ? frame['@context'] || {} : {};\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), frameContext, options);\n\n  // mode specific defaults\n  if(!options.hasOwnProperty('omitGraph')) {\n    options.omitGraph = _processingMode(activeCtx, 1.1);\n  }\n  if(!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {\n    options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);\n  }\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // expand frame\n  const opts = {...options};\n  opts.isFrame = true;\n  opts.keepFreeFloatingNodes = true;\n  const expandedFrame = await jsonld.expand(frame, opts);\n\n  // if the unexpanded frame includes a key expanding to @graph, frame the\n  // default graph, otherwise, the merged graph\n  const frameKeys = Object.keys(frame)\n    .map(key => _expandIri(activeCtx, key, {vocab: true}));\n  opts.merged = !frameKeys.includes('@graph');\n  opts.is11 = _processingMode(activeCtx, 1.1);\n\n  // do framing\n  const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n  opts.graph = !options.omitGraph;\n  opts.skipExpansion = true;\n  opts.link = {};\n  opts.framing = true;\n  let compacted = await jsonld.compact(framed, frameContext, opts);\n\n  // replace @null with null, compacting arrays\n  opts.link = {};\n  compacted = _cleanupNull(compacted, opts);\n\n  return compacted;\n};\n\n/**\n * **Experimental**\n *\n * Links a JSON-LD document's nodes in memory.\n *\n * @param input the JSON-LD document to link.\n * @param [ctx] the JSON-LD context to apply.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the linked output.\n */\njsonld.link = async function(input, ctx, options) {\n  // API matches running frame with a wildcard frame and embed: '@link'\n  // get arguments\n  const frame = {};\n  if(ctx) {\n    frame['@context'] = ctx;\n  }\n  frame['@embed'] = '@link';\n  return jsonld.frame(input, frame, options);\n};\n\n/**\n * Performs RDF dataset normalization on the given input. The input is JSON-LD\n * unless the 'inputFormat' option is used. The output is an RDF dataset\n * unless the 'format' option is used.\n *\n * @param input the input to normalize as JSON-LD or as a format specified by\n *          the 'inputFormat' option.\n * @param [options] the options to use:\n *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n *            `URGNA2012` (default: `URDNA2015`).\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [inputFormat] the format if input is not JSON-LD:\n *            'application/n-quads' for N-Quads.\n *          [format] the format if output is a string:\n *            'application/n-quads' for N-Quads.\n *          [documentLoader(url, options)] the document loader.\n *          [useNative] true to use a native canonize algorithm\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the normalized output.\n */\njsonld.normalize = jsonld.canonize = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not canonize, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    algorithm: 'URDNA2015',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if('inputFormat' in options) {\n    if(options.inputFormat !== 'application/n-quads' &&\n      options.inputFormat !== 'application/nquads') {\n      throw new JsonLdError(\n        'Unknown canonicalization input format.',\n        'jsonld.CanonizeError');\n    }\n    // TODO: `await` for async parsers\n    const parsedInput = NQuads.parse(input);\n\n    // do canonicalization\n    return canonize.canonize(parsedInput, options);\n  }\n\n  // convert to RDF dataset then do normalization\n  const opts = {...options};\n  delete opts.format;\n  opts.produceGeneralizedRdf = false;\n  const dataset = await jsonld.toRDF(input, opts);\n\n  // do canonicalization\n  return canonize.canonize(dataset, options);\n};\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset a serialized string of RDF in a format specified by the\n *          format option or an RDF dataset to convert.\n * @param [options] the options to use:\n *          [format] the format if dataset param must first be parsed:\n *            'application/n-quads' for N-Quads (default).\n *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n *          [useRdfType] true to use rdf:type, false to use @type\n *            (default: false).\n *          [useNativeTypes] true to convert XSD types into native types\n *            (boolean, integer, double), false not to (default: false).\n *\n * @return a Promise that resolves to the JSON-LD document.\n */\njsonld.fromRDF = async function(dataset, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert from RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    format: _isString(dataset) ? 'application/n-quads' : undefined\n  });\n\n  const {format} = options;\n  let {rdfParser} = options;\n\n  // handle special format\n  if(format) {\n    // check supported formats\n    rdfParser = rdfParser || _rdfParsers[format];\n    if(!rdfParser) {\n      throw new JsonLdError(\n        'Unknown input format.',\n        'jsonld.UnknownFormat', {format});\n    }\n  } else {\n    // no-op parser, assume dataset already parsed\n    rdfParser = () => dataset;\n  }\n\n  // rdfParser must be synchronous or return a promise, no callback support\n  const parsedDataset = await rdfParser(dataset);\n  return _fromRDF(parsedDataset, options);\n};\n\n/**\n * Outputs the RDF dataset found in the given JSON-LD object.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [format] the format to use to output a string:\n *            'application/n-quads' for N-Quads.\n *          [produceGeneralizedRdf] true to output generalized RDF, false\n *            to produce only standard RDF (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the RDF dataset.\n */\njsonld.toRDF = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert to RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // TODO: support toRDF custom map?\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    // expand input\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // output RDF dataset\n  const dataset = _toRDF(expanded, options);\n  if(options.format) {\n    if(options.format === 'application/n-quads' ||\n      options.format === 'application/nquads') {\n      return await NQuads.serialize(dataset);\n    }\n    throw new JsonLdError(\n      'Unknown output format.',\n      'jsonld.UnknownFormat', {format: options.format});\n  }\n\n  return dataset;\n};\n\n/**\n * **Experimental**\n *\n * Recursively flattens the nodes in the given JSON-LD input into a merged\n * map of node ID => node. All graphs will be merged into the default graph.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged node map.\n */\njsonld.createNodeMap = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not create node map, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  return _createMergedNodeMap(expanded, options);\n};\n\n/**\n * **Experimental**\n *\n * Merges two or more JSON-LD documents into a single flattened document.\n *\n * @param docs the JSON-LD documents to merge together.\n * @param ctx the context to use to compact the merged result, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [mergeNodes] true to merge properties for nodes with the same ID,\n *            false to ignore new properties for nodes with the same ID once\n *            the ID has been defined; note that this may not prevent merging\n *            new properties where a node is in the `object` position\n *            (default: true).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged output.\n */\njsonld.merge = async function(docs, ctx, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not merge, too few arguments.');\n  }\n  if(!_isArray(docs)) {\n    throw new TypeError('Could not merge, \"docs\" must be an array.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand all documents\n  const expanded = await Promise.all(docs.map(doc => {\n    const opts = {...options};\n    return jsonld.expand(doc, opts);\n  }));\n\n  let mergeNodes = true;\n  if('mergeNodes' in options) {\n    mergeNodes = options.mergeNodes;\n  }\n\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n\n  for(let i = 0; i < expanded.length; ++i) {\n    // uniquely relabel blank nodes\n    const doc = util.relabelBlankNodes(expanded[i], {\n      issuer: new IdentifierIssuer('_:b' + i + '-')\n    });\n\n    // add nodes to the shared node map graphs if merging nodes, to a\n    // separate graph set if not\n    const _graphs = (mergeNodes || i === 0) ? graphs : {'@default': {}};\n    _createNodeMap(doc, _graphs, '@default', issuer);\n\n    if(_graphs !== graphs) {\n      // merge document graphs but don't merge existing nodes\n      for(const graphName in _graphs) {\n        const _nodeMap = _graphs[graphName];\n        if(!(graphName in graphs)) {\n          graphs[graphName] = _nodeMap;\n          continue;\n        }\n        const nodeMap = graphs[graphName];\n        for(const key in _nodeMap) {\n          if(!(key in nodeMap)) {\n            nodeMap[key] = _nodeMap[key];\n          }\n        }\n      }\n    }\n  }\n\n  // add all non-default graphs to default graph\n  const defaultGraph = _mergeNodeMaps(graphs);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n\n  if(ctx === null) {\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * The default document loader for external documents.\n *\n * @param url the URL to load.\n *\n * @return a promise that resolves to the remote document.\n */\nObject.defineProperty(jsonld, 'documentLoader', {\n  get: () => jsonld._documentLoader,\n  set: v => jsonld._documentLoader = v\n});\n// default document loader not implemented\njsonld.documentLoader = async url => {\n  throw new JsonLdError(\n    'Could not retrieve a JSON-LD document from the URL. URL ' +\n    'dereferencing not implemented.', 'jsonld.LoadDocumentError',\n    {code: 'loading document failed', url});\n};\n\n/**\n * Gets a remote JSON-LD document using the default document loader or\n * one given in the passed options.\n *\n * @param url the URL to fetch.\n * @param [options] the options to use:\n *          [documentLoader] the document loader to use.\n *\n * @return a Promise that resolves to the retrieved remote document.\n */\njsonld.get = async function(url, options) {\n  let load;\n  if(typeof options.documentLoader === 'function') {\n    load = options.documentLoader;\n  } else {\n    load = jsonld.documentLoader;\n  }\n\n  const remoteDoc = await load(url);\n\n  try {\n    if(!remoteDoc.document) {\n      throw new JsonLdError(\n        'No remote document found at the given URL.',\n        'jsonld.NullRemoteDocument');\n    }\n    if(_isString(remoteDoc.document)) {\n      remoteDoc.document = JSON.parse(remoteDoc.document);\n    }\n  } catch(e) {\n    throw new JsonLdError(\n      'Could not retrieve a JSON-LD document from the URL.',\n      'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n  }\n\n  return remoteDoc;\n};\n\n/**\n * Processes a local context, resolving any URLs as necessary, and returns a\n * new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param [options] the options to use:\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the new active context.\n */\njsonld.processContext = async function(\n  activeCtx, localCtx, options) {\n  // set default options\n  options = _setDefaults(options, {\n    base: '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // return initial context early for null context\n  if(localCtx === null) {\n    return _getInitialContext(options);\n  }\n\n  // get URLs in localCtx\n  localCtx = util.clone(localCtx);\n  if(!(_isObject(localCtx) && '@context' in localCtx)) {\n    localCtx = {'@context': localCtx};\n  }\n\n  return _processContext({activeCtx, localCtx, options});\n};\n\n// backwards compatibility\njsonld.getContextValue = require('./context').getContextValue;\n\n/**\n * Document loaders.\n */\njsonld.documentLoaders = {};\njsonld.documentLoaders.node = require('./documentLoaders/node');\njsonld.documentLoaders.xhr = require('./documentLoaders/xhr');\n\n/**\n * Assigns the default document loader for external document URLs to a built-in\n * default. Supported types currently include: 'xhr' and 'node'.\n *\n * @param type the type to set.\n * @param [params] the parameters required to use the document loader.\n */\njsonld.useDocumentLoader = function(type) {\n  if(!(type in jsonld.documentLoaders)) {\n    throw new JsonLdError(\n      'Unknown document loader type: \"' + type + '\"',\n      'jsonld.UnknownDocumentLoader',\n      {type});\n  }\n\n  // set document loader\n  jsonld.documentLoader = jsonld.documentLoaders[type].apply(\n    jsonld, Array.prototype.slice.call(arguments, 1));\n};\n\n/**\n * Registers an RDF dataset parser by content-type, for use with\n * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n * a string of input. An RDF dataset parser can be synchronous or\n * asynchronous (by returning a promise).\n *\n * @param contentType the content-type for the parser.\n * @param parser(input) the parser function (takes a string as a parameter\n *          and either returns an RDF dataset or a Promise that resolves to one.\n */\njsonld.registerRDFParser = function(contentType, parser) {\n  _rdfParsers[contentType] = parser;\n};\n\n/**\n * Unregisters an RDF dataset parser by content-type.\n *\n * @param contentType the content-type for the parser.\n */\njsonld.unregisterRDFParser = function(contentType) {\n  delete _rdfParsers[contentType];\n};\n\n// register the N-Quads RDF parser\njsonld.registerRDFParser('application/n-quads', NQuads.parse);\njsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n// register the RDFa API RDF parser\njsonld.registerRDFParser('rdfa-api', Rdfa.parse);\n\n/* URL API */\njsonld.url = require('./url');\n\n/* Utility API */\njsonld.util = util;\n// backwards compatibility\nObject.assign(jsonld, util);\n\n// reexpose API as jsonld.promises for backwards compatability\njsonld.promises = jsonld;\n\n// backwards compatibility\njsonld.RequestQueue = require('./RequestQueue');\n\n/* WebIDL API */\njsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld);\n\n// setup browser global JsonLdProcessor\nif(_browser && typeof global.JsonLdProcessor === 'undefined') {\n  Object.defineProperty(global, 'JsonLdProcessor', {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: jsonld.JsonLdProcessor\n  });\n}\n\n// set platform-specific defaults/APIs\nif(_nodejs) {\n  // use node document loader by default\n  jsonld.useDocumentLoader('node');\n} else if(typeof XMLHttpRequest !== 'undefined') {\n  // use xhr document loader by default\n  jsonld.useDocumentLoader('xhr');\n}\n\nfunction _setDefaults(options, {\n  documentLoader = jsonld.documentLoader,\n  ...defaults\n}) {\n  return Object.assign({}, {documentLoader}, defaults, options);\n}\n\n// end of jsonld API `wrapper` factory\nreturn jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function() {\n  return wrapper(function() {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;\n"]},"metadata":{},"sourceType":"script"}