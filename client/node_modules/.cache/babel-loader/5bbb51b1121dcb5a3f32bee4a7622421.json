{"ast":null,"code":"/**\n * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst util = require('./util');\n\nmodule.exports = class AsyncAlgorithm {\n  constructor({\n    maxCallStackDepth = 500,\n    maxTotalCallStackDepth = 0xFFFFFFFF,\n    // milliseconds\n    timeSlice = 10\n  } = {}) {\n    this.schedule = {};\n    this.schedule.MAX_DEPTH = maxCallStackDepth;\n    this.schedule.MAX_TOTAL_DEPTH = maxTotalCallStackDepth;\n    this.schedule.depth = 0;\n    this.schedule.totalDepth = 0;\n    this.schedule.timeSlice = timeSlice;\n  } // do some work in a time slice, but in serial\n\n\n  doWork(fn, callback) {\n    const schedule = this.schedule;\n\n    if (schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {\n      return callback(new Error('Maximum total call stack depth exceeded; canonicalization aborting.'));\n    }\n\n    (function work() {\n      if (schedule.depth === schedule.MAX_DEPTH) {\n        // stack too deep, run on next tick\n        schedule.depth = 0;\n        schedule.running = false;\n        return util.nextTick(work);\n      } // if not yet running, force run\n\n\n      const now = Date.now();\n\n      if (!schedule.running) {\n        schedule.start = Date.now();\n        schedule.deadline = schedule.start + schedule.timeSlice;\n      } // TODO: should also include an estimate of expectedWorkTime\n\n\n      if (now < schedule.deadline) {\n        schedule.running = true;\n        schedule.depth++;\n        schedule.totalDepth++;\n        return fn((err, result) => {\n          schedule.depth--;\n          schedule.totalDepth--;\n          callback(err, result);\n        });\n      } // not enough time left in this slice, run after letting browser\n      // do some other things\n\n\n      schedule.depth = 0;\n      schedule.running = false;\n      util.setImmediate(work);\n    })();\n  } // asynchronously loop\n\n\n  forEach(iterable, fn, callback) {\n    const self = this;\n    let iterator;\n    let idx = 0;\n    let length;\n\n    if (Array.isArray(iterable)) {\n      length = iterable.length;\n\n      iterator = () => {\n        if (idx === length) {\n          return false;\n        }\n\n        iterator.value = iterable[idx++];\n        iterator.key = idx;\n        return true;\n      };\n    } else {\n      const keys = Object.keys(iterable);\n      length = keys.length;\n\n      iterator = () => {\n        if (idx === length) {\n          return false;\n        }\n\n        iterator.key = keys[idx++];\n        iterator.value = iterable[iterator.key];\n        return true;\n      };\n    }\n\n    (function iterate(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (iterator()) {\n        return self.doWork(() => fn(iterator.value, iterator.key, iterate));\n      }\n\n      callback();\n    })();\n  } // asynchronous waterfall\n\n\n  waterfall(fns, callback) {\n    const self = this;\n    self.forEach(fns, (fn, idx, callback) => self.doWork(fn, callback), callback);\n  } // asynchronous while\n\n\n  whilst(condition, fn, callback) {\n    const self = this;\n\n    (function loop(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!condition()) {\n        return callback();\n      }\n\n      self.doWork(fn, loop);\n    })();\n  }\n\n};","map":{"version":3,"sources":["/app/node_modules/rdf-canonize/lib/AsyncAlgorithm.js"],"names":["util","require","module","exports","AsyncAlgorithm","constructor","maxCallStackDepth","maxTotalCallStackDepth","timeSlice","schedule","MAX_DEPTH","MAX_TOTAL_DEPTH","depth","totalDepth","doWork","fn","callback","Error","work","running","nextTick","now","Date","start","deadline","err","result","setImmediate","forEach","iterable","self","iterator","idx","length","Array","isArray","value","key","keys","Object","iterate","waterfall","fns","whilst","condition","loop"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst util = require('./util');\n\nmodule.exports = class AsyncAlgorithm {\n  constructor({\n    maxCallStackDepth = 500,\n    maxTotalCallStackDepth = 0xFFFFFFFF,\n    // milliseconds\n    timeSlice = 10\n  } = {}) {\n    this.schedule = {};\n    this.schedule.MAX_DEPTH = maxCallStackDepth;\n    this.schedule.MAX_TOTAL_DEPTH = maxTotalCallStackDepth;\n    this.schedule.depth = 0;\n    this.schedule.totalDepth = 0;\n    this.schedule.timeSlice = timeSlice;\n  }\n\n  // do some work in a time slice, but in serial\n  doWork(fn, callback) {\n    const schedule = this.schedule;\n\n    if(schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {\n      return callback(new Error(\n        'Maximum total call stack depth exceeded; canonicalization aborting.'));\n    }\n\n    (function work() {\n      if(schedule.depth === schedule.MAX_DEPTH) {\n        // stack too deep, run on next tick\n        schedule.depth = 0;\n        schedule.running = false;\n        return util.nextTick(work);\n      }\n\n      // if not yet running, force run\n      const now = Date.now();\n      if(!schedule.running) {\n        schedule.start = Date.now();\n        schedule.deadline = schedule.start + schedule.timeSlice;\n      }\n\n      // TODO: should also include an estimate of expectedWorkTime\n      if(now < schedule.deadline) {\n        schedule.running = true;\n        schedule.depth++;\n        schedule.totalDepth++;\n        return fn((err, result) => {\n          schedule.depth--;\n          schedule.totalDepth--;\n          callback(err, result);\n        });\n      }\n\n      // not enough time left in this slice, run after letting browser\n      // do some other things\n      schedule.depth = 0;\n      schedule.running = false;\n      util.setImmediate(work);\n    })();\n  }\n\n  // asynchronously loop\n  forEach(iterable, fn, callback) {\n    const self = this;\n    let iterator;\n    let idx = 0;\n    let length;\n    if(Array.isArray(iterable)) {\n      length = iterable.length;\n      iterator = () => {\n        if(idx === length) {\n          return false;\n        }\n        iterator.value = iterable[idx++];\n        iterator.key = idx;\n        return true;\n      };\n    } else {\n      const keys = Object.keys(iterable);\n      length = keys.length;\n      iterator = () => {\n        if(idx === length) {\n          return false;\n        }\n        iterator.key = keys[idx++];\n        iterator.value = iterable[iterator.key];\n        return true;\n      };\n    }\n\n    (function iterate(err) {\n      if(err) {\n        return callback(err);\n      }\n      if(iterator()) {\n        return self.doWork(() => fn(iterator.value, iterator.key, iterate));\n      }\n      callback();\n    })();\n  }\n\n  // asynchronous waterfall\n  waterfall(fns, callback) {\n    const self = this;\n    self.forEach(\n      fns, (fn, idx, callback) => self.doWork(fn, callback), callback);\n  }\n\n  // asynchronous while\n  whilst(condition, fn, callback) {\n    const self = this;\n    (function loop(err) {\n      if(err) {\n        return callback(err);\n      }\n      if(!condition()) {\n        return callback();\n      }\n      self.doWork(fn, loop);\n    })();\n  }\n};\n"]},"metadata":{},"sourceType":"script"}