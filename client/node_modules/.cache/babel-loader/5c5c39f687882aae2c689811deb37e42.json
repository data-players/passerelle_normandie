{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  parseLinkHeader,\n  buildHeaders\n} = require('../util');\n\nconst {\n  LINK_HEADER_CONTEXT\n} = require('../constants');\n\nconst JsonLdError = require('../JsonLdError');\n\nconst RequestQueue = require('../RequestQueue');\n\nconst {\n  prependBase\n} = require('../url');\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\n\n\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  request,\n  headers = {}\n} = {\n  strictSSL: true,\n  maxRedirects: -1,\n  headers: {}\n}) => {\n  headers = buildHeaders(headers); // TODO: use `axios`\n\n  request = request || require('request');\n\n  const http = require('http');\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function (url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    if (url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError('URL could not be dereferenced; only \"http\" and \"https\" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url\n      });\n    }\n\n    if (secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\\'s scheme is not \"https\".', 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url\n      });\n    } // TODO: disable cache until HTTP caching implemented\n\n\n    let doc = null; //cache.get(url);\n\n    if (doc !== null) {\n      return doc;\n    }\n\n    let result;\n    let alternate = null;\n\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch (e) {\n      throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        url,\n        cause: e\n      });\n    }\n\n    const {\n      res,\n      body\n    } = result;\n    doc = {\n      contextUrl: null,\n      documentUrl: url,\n      document: body || null\n    }; // handle error\n\n    const statusText = http.STATUS_CODES[res.statusCode];\n\n    if (res.statusCode >= 400) {\n      throw new JsonLdError(`URL \"${url}\" could not be dereferenced: ${statusText}`, 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url,\n        httpStatusCode: res.statusCode\n      });\n    } // handle Link Header\n\n\n    if (res.headers.link && res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(res.headers.link);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n\n      if (Array.isArray(linkedContext)) {\n        throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {\n          code: 'multiple context link headers',\n          url\n        });\n      }\n\n      if (linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      } // \"alternate\" link header is a redirect\n\n\n      alternate = linkHeaders['alternate'];\n\n      if (alternate && alternate.type == 'application/ld+json' && !(res.headers['content-type'] || '').match(/^application\\/(\\w*\\+)?json$/)) {\n        res.headers.location = prependBase(url, alternate.target);\n      }\n    } // handle redirect\n\n\n    if ((alternate || res.statusCode >= 300 && res.statusCode < 400) && res.headers.location) {\n      if (redirects.length === maxRedirects) {\n        throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode,\n          redirects\n        });\n      }\n\n      if (redirects.indexOf(url) !== -1) {\n        throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {\n          code: 'recursive context inclusion',\n          url,\n          httpStatusCode: res.statusCode,\n          redirects\n        });\n      }\n\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    } // cache for each redirected URL\n\n\n    redirects.push(url); // TODO: disable cache until HTTP caching implemented\n\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({\n          res,\n          body\n        });\n      }\n    });\n  });\n}","map":{"version":3,"sources":["/app/node_modules/jsonld/lib/documentLoaders/node.js"],"names":["parseLinkHeader","buildHeaders","require","LINK_HEADER_CONTEXT","JsonLdError","RequestQueue","prependBase","module","exports","secure","strictSSL","maxRedirects","request","headers","http","queue","wrapLoader","url","loadDocument","redirects","indexOf","code","doc","result","alternate","_request","followRedirect","e","cause","res","body","contextUrl","documentUrl","document","statusText","STATUS_CODES","statusCode","httpStatusCode","link","linkHeaders","linkedContext","Array","isArray","target","type","match","location","length","push","options","Promise","resolve","reject","err"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {parseLinkHeader, buildHeaders} = require('../util');\nconst {LINK_HEADER_CONTEXT} = require('../constants');\nconst JsonLdError = require('../JsonLdError');\nconst RequestQueue = require('../RequestQueue');\nconst {prependBase} = require('../url');\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  request,\n  headers = {}\n} = {strictSSL: true, maxRedirects: -1, headers: {}}) => {\n  headers = buildHeaders(headers);\n  // TODO: use `axios`\n  request = request || require('request');\n  const http = require('http');\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function(url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    if(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    // TODO: disable cache until HTTP caching implemented\n    let doc = null;//cache.get(url);\n    if(doc !== null) {\n      return doc;\n    }\n\n    let result;\n    let alternate = null;\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch(e) {\n      throw new JsonLdError(\n        'URL could not be dereferenced, an error occurred.',\n        'jsonld.LoadDocumentError',\n        {code: 'loading document failed', url, cause: e});\n    }\n\n    const {res, body} = result;\n\n    doc = {contextUrl: null, documentUrl: url, document: body || null};\n\n    // handle error\n    const statusText = http.STATUS_CODES[res.statusCode];\n    if(res.statusCode >= 400) {\n      throw new JsonLdError(\n        `URL \"${url}\" could not be dereferenced: ${statusText}`,\n        'jsonld.InvalidUrl', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode\n        });\n    }\n\n    // handle Link Header\n    if(res.headers.link &&\n      res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(res.headers.link);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n      if(Array.isArray(linkedContext)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one associated ' +\n          'HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      }\n\n      // \"alternate\" link header is a redirect\n      alternate = linkHeaders['alternate'];\n      if(alternate &&\n        alternate.type == 'application/ld+json' &&\n        !(res.headers['content-type'] || '')\n          .match(/^application\\/(\\w*\\+)?json$/)) {\n        res.headers.location = prependBase(url, alternate.target);\n      }\n    }\n\n    // handle redirect\n    if((alternate ||\n      res.statusCode >= 300 && res.statusCode < 400) && res.headers.location) {\n      if(redirects.length === maxRedirects) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; there were too many redirects.',\n          'jsonld.TooManyRedirects', {\n            code: 'loading document failed',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      if(redirects.indexOf(url) !== -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; infinite redirection was detected.',\n          'jsonld.InfiniteRedirectDetected', {\n            code: 'recursive context inclusion',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if(err) {\n        reject(err);\n      } else {\n        resolve({res, body});\n      }\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"script"}