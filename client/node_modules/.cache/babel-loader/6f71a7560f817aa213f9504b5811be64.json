{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  isKeyword\n} = require('./context');\n\nconst graphTypes = require('./graphTypes');\n\nconst types = require('./types');\n\nconst util = require('./util');\n\nconst JsonLdError = require('./JsonLdError');\n\nconst api = {};\nmodule.exports = api;\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\n\napi.createMergedNodeMap = (input, options) => {\n  options = options || {}; // produce a map of all subjects and name each bnode\n\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {\n    '@default': {}\n  };\n  api.createNodeMap(input, graphs, '@default', issuer); // add all non-default graphs to default graph\n\n  return api.mergeNodeMaps(graphs);\n};\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\n\n\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if (types.isArray(input)) {\n    for (const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n\n    return;\n  } // add non-object to list\n\n\n  if (!types.isObject(input)) {\n    if (list) {\n      list.push(input);\n    }\n\n    return;\n  } // add values to list\n\n\n  if (graphTypes.isValue(input)) {\n    if ('@type' in input) {\n      let type = input['@type']; // rename @type blank node\n\n      if (type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n\n    if (list) {\n      list.push(input);\n    }\n\n    return;\n  } else if (list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({\n      '@list': _list\n    });\n    return;\n  } // Note: At this point, input must be a subject.\n  // spec requires @type to be named first, so assign names early\n\n\n  if ('@type' in input) {\n    const types = input['@type'];\n\n    for (const type of types) {\n      if (type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  } // get name for subject\n\n\n  if (types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ? issuer.getId(input['@id']) : input['@id'];\n  } // add subject reference to list\n\n\n  if (list) {\n    list.push({\n      '@id': name\n    });\n  } // create new subject or merge into existing one\n\n\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n\n  for (let property of properties) {\n    // skip @id\n    if (property === '@id') {\n      continue;\n    } // handle reverse properties\n\n\n    if (property === '@reverse') {\n      const referencedNode = {\n        '@id': name\n      };\n      const reverseMap = input['@reverse'];\n\n      for (const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n\n        for (const item of items) {\n          let itemName = item['@id'];\n\n          if (graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(subjects[itemName], reverseProperty, referencedNode, {\n            propertyIsArray: true,\n            allowDuplicate: false\n          });\n        }\n      }\n\n      continue;\n    } // recurse into graph\n\n\n    if (property === '@graph') {\n      // add graph subjects map entry\n      if (!(name in graphs)) {\n        graphs[name] = {};\n      }\n\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    } // recurse into included\n\n\n    if (property === '@included') {\n      api.createNodeMap(input[property], graphs, graph, issuer);\n      continue;\n    } // copy non-@type keywords\n\n\n    if (property !== '@type' && isKeyword(property)) {\n      if (property === '@index' && property in subject && (input[property] !== subject[property] || input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError('Invalid JSON-LD syntax; conflicting @index property detected.', 'jsonld.SyntaxError', {\n          code: 'conflicting indexes',\n          subject\n        });\n      }\n\n      subject[property] = input[property];\n      continue;\n    } // iterate over objects\n\n\n    const objects = input[property]; // if property is a bnode, assign it a new id\n\n    if (property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    } // ensure property is added for empty arrays\n\n\n    if (objects.length === 0) {\n      util.addValue(subject, property, [], {\n        propertyIsArray: true\n      });\n      continue;\n    }\n\n    for (let o of objects) {\n      if (property === '@type') {\n        // rename @type blank nodes\n        o = o.indexOf('_:') === 0 ? issuer.getId(o) : o;\n      } // handle embedded subject or subject reference\n\n\n      if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // skip null @id\n        if ('@id' in o && !o['@id']) {\n          continue;\n        } // relabel blank node @id\n\n\n        const id = graphTypes.isBlankNode(o) ? issuer.getId(o['@id']) : o['@id']; // add reference and recurse\n\n        util.addValue(subject, property, {\n          '@id': id\n        }, {\n          propertyIsArray: true,\n          allowDuplicate: false\n        });\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if (graphTypes.isValue(o)) {\n        util.addValue(subject, property, o, {\n          propertyIsArray: true,\n          allowDuplicate: false\n        });\n      } else if (graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {\n          '@list': _list\n        };\n        util.addValue(subject, property, o, {\n          propertyIsArray: true,\n          allowDuplicate: false\n        });\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(subject, property, o, {\n          propertyIsArray: true,\n          allowDuplicate: false\n        });\n      }\n    }\n  }\n};\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\n\n\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n\n  for (const name of Object.keys(graphs).sort()) {\n    for (const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n\n      if (!(id in merged)) {\n        merged[id] = {\n          '@id': id\n        };\n      }\n\n      const mergedNode = merged[id];\n\n      for (const property of Object.keys(node).sort()) {\n        if (isKeyword(property) && property !== '@type') {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for (const value of node[property]) {\n            util.addValue(mergedNode, property, util.clone(value), {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n\n  for (const graphName of graphNames) {\n    if (graphName === '@default') {\n      continue;\n    }\n\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n\n    if (!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if (!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n\n    const graph = subject['@graph'];\n\n    for (const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id]; // only add full subjects\n\n      if (!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n\n  return defaultGraph;\n};","map":{"version":3,"sources":["/app/node_modules/jsonld/lib/nodeMap.js"],"names":["isKeyword","require","graphTypes","types","util","JsonLdError","api","module","exports","createMergedNodeMap","input","options","issuer","IdentifierIssuer","graphs","createNodeMap","mergeNodeMaps","graph","name","list","isArray","node","undefined","isObject","push","isValue","type","indexOf","getId","isList","_list","isUndefined","isBlankNode","subjects","subject","properties","Object","keys","sort","property","referencedNode","reverseMap","reverseProperty","items","item","itemName","addValue","propertyIsArray","allowDuplicate","code","objects","length","o","isSubject","isSubjectReference","id","mergeNodeMapGraphs","merged","mergedNode","clone","value","defaultGraph","graphNames","graphName","nodeMap"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst util = require('./util');\nconst JsonLdError = require('./JsonLdError');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = (input, options) => {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if(types.isArray(input)) {\n    for(const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n    return;\n  }\n\n  // add non-object to list\n  if(!types.isObject(input)) {\n    if(list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if(graphTypes.isValue(input)) {\n    if('@type' in input) {\n      let type = input['@type'];\n      // rename @type blank node\n      if(type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if(list) {\n      list.push(input);\n    }\n    return;\n  } else if(list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({'@list': _list});\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if('@type' in input) {\n    const types = input['@type'];\n    for(const type of types) {\n      if(type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  }\n\n  // get name for subject\n  if(types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ?\n      issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if(list) {\n    list.push({'@id': name});\n  }\n\n  // create new subject or merge into existing one\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n  for(let property of properties) {\n    // skip @id\n    if(property === '@id') {\n      continue;\n    }\n\n    // handle reverse properties\n    if(property === '@reverse') {\n      const referencedNode = {'@id': name};\n      const reverseMap = input['@reverse'];\n      for(const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n        for(const item of items) {\n          let itemName = item['@id'];\n          if(graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(\n            subjects[itemName], reverseProperty, referencedNode,\n            {propertyIsArray: true, allowDuplicate: false});\n        }\n      }\n      continue;\n    }\n\n    // recurse into graph\n    if(property === '@graph') {\n      // add graph subjects map entry\n      if(!(name in graphs)) {\n        graphs[name] = {};\n      }\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    }\n\n    // recurse into included\n    if(property === '@included') {\n      api.createNodeMap(input[property], graphs, graph, issuer);\n      continue;\n    }\n\n    // copy non-@type keywords\n    if(property !== '@type' && isKeyword(property)) {\n      if(property === '@index' && property in subject &&\n        (input[property] !== subject[property] ||\n        input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; conflicting @index property detected.',\n          'jsonld.SyntaxError',\n          {code: 'conflicting indexes', subject});\n      }\n      subject[property] = input[property];\n      continue;\n    }\n\n    // iterate over objects\n    const objects = input[property];\n\n    // if property is a bnode, assign it a new id\n    if(property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    }\n\n    // ensure property is added for empty arrays\n    if(objects.length === 0) {\n      util.addValue(subject, property, [], {propertyIsArray: true});\n      continue;\n    }\n    for(let o of objects) {\n      if(property === '@type') {\n        // rename @type blank nodes\n        o = (o.indexOf('_:') === 0) ? issuer.getId(o) : o;\n      }\n\n      // handle embedded subject or subject reference\n      if(graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // skip null @id\n        if('@id' in o && !o['@id']) {\n          continue;\n        }\n\n        // relabel blank node @id\n        const id = graphTypes.isBlankNode(o) ?\n          issuer.getId(o['@id']) : o['@id'];\n\n        // add reference and recurse\n        util.addValue(\n          subject, property, {'@id': id},\n          {propertyIsArray: true, allowDuplicate: false});\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if(graphTypes.isValue(o)) {\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else if(graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {'@list': _list};\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(\n          subject, property, o, {propertyIsArray: true, allowDuplicate: false});\n      }\n    }\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n  for(const name of Object.keys(graphs).sort()) {\n    for(const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n      if(!(id in merged)) {\n        merged[id] = {'@id': id};\n      }\n      const mergedNode = merged[id];\n\n      for(const property of Object.keys(node).sort()) {\n        if(isKeyword(property) && property !== '@type') {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for(const value of node[property]) {\n            util.addValue(\n              mergedNode, property, util.clone(value),\n              {propertyIsArray: true, allowDuplicate: false});\n          }\n        }\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n  for(const graphName of graphNames) {\n    if(graphName === '@default') {\n      continue;\n    }\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n    if(!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if(!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n    const graph = subject['@graph'];\n    for(const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id];\n      // only add full subjects\n      if(!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n  return defaultGraph;\n};\n"]},"metadata":{},"sourceType":"script"}