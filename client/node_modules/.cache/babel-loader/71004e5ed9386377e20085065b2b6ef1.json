{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSubject: _isSubject\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\n\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null,\n  expansionMap = () => undefined\n}) => {\n  // nothing to expand\n  if (element === null || element === undefined) {\n    return null;\n  } // disable framing if activeProperty is @default\n\n\n  if (activeProperty === '@default') {\n    options = Object.assign({}, options, {\n      isFrame: false\n    });\n  }\n\n  if (!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists unless custom mapped\n    if (!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, {\n      vocab: true\n    }, options) === '@graph')) {\n      const mapped = await expansionMap({\n        unmappedValue: element,\n        activeCtx,\n        activeProperty,\n        options,\n        insideList\n      });\n\n      if (mapped === undefined) {\n        return null;\n      }\n\n      return mapped;\n    } // expand element according to value expansion rules\n\n\n    return _expandValue({\n      activeCtx,\n      activeProperty,\n      value: element,\n      options\n    });\n  } // recursively expand array\n\n\n  if (_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n\n    for (let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        expansionMap,\n        insideIndex,\n        typeScopedContext\n      });\n\n      if (insideList && _isArray(e)) {\n        e = {\n          '@list': e\n        };\n      }\n\n      if (e === null) {\n        e = await expansionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options,\n          expandedParent: rval,\n          insideList\n        });\n\n        if (e === undefined) {\n          continue;\n        }\n      }\n\n      if (_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n\n    return rval;\n  } // recursively expand object:\n  // first, expand the active property\n\n\n  const expandedActiveProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options); // Get any property-scoped context for activeProperty\n\n\n  const propertyScopedCtx = _getContextValue(activeCtx, activeProperty, '@context'); // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n\n\n  typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n\n  if (mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes('@context')) {\n    for (const key of keys) {\n      const expandedProperty = _expandIri(typeScopedContext, key, {\n        vocab: true\n      }, options);\n\n      if (expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n\n      if (expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if (mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  } // apply property-scoped context after reverting term-scoped context\n\n\n  if (!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  } // if element has a context, process it\n\n\n  if ('@context' in element) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: element['@context'],\n      options\n    });\n  } // set the type-scoped context to the context on input, for use later\n\n\n  typeScopedContext = activeCtx; // Remember the first key found expanding to @type\n\n  let typeKey = null; // look for scoped contexts on `@type`\n\n  for (const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {\n      vocab: true\n    }, options);\n\n    if (expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];\n\n      for (const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n\n        if (!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  } // process each key and value in element, ignoring @nest content\n\n\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeKey,\n    typeScopedContext,\n    expansionMap\n  }); // get property count on expanded output\n\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if ('@value' in rval) {\n    // @value must only have @language or @type\n    if ('@type' in rval && ('@language' in rval || '@direction' in rval)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may not ' + 'contain both \"@type\" and either \"@language\" or \"@direction\".', 'jsonld.SyntaxError', {\n        code: 'invalid value object',\n        element: rval\n      });\n    }\n\n    let validCount = count - 1;\n\n    if ('@type' in rval) {\n      validCount -= 1;\n    }\n\n    if ('@index' in rval) {\n      validCount -= 1;\n    }\n\n    if ('@language' in rval) {\n      validCount -= 1;\n    }\n\n    if ('@direction' in rval) {\n      validCount -= 1;\n    }\n\n    if (validCount !== 0) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may only ' + 'have an \"@index\" property and either \"@type\" ' + 'or either or both \"@language\" or \"@direction\".', 'jsonld.SyntaxError', {\n        code: 'invalid value object',\n        element: rval\n      });\n    }\n\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n\n    const types = _getValues(rval, '@type'); // drop null @values unless custom mapped\n\n\n    if (_processingMode(activeCtx, 1.1) && types.includes('@json') && types.length === 1) {// Any value of @value is okay if @type: @json\n    } else if (values.length === 0) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n\n      if (mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    } else if (!values.every(v => _isString(v) || _isEmptyObject(v)) && '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError('Invalid JSON-LD syntax; only strings may be language-tagged.', 'jsonld.SyntaxError', {\n        code: 'invalid language-tagged value',\n        element: rval\n      });\n    } else if (!types.every(t => _isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) || _isEmptyObject(t))) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' + 'must have an absolute IRI for the value of \"@type\".', 'jsonld.SyntaxError', {\n        code: 'invalid typed value',\n        element: rval\n      });\n    }\n  } else if ('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if ('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if (count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property \"@set\" ' + 'or \"@list\", then it can have at most one other property that is ' + '\"@index\".', 'jsonld.SyntaxError', {\n        code: 'invalid set or list object',\n        element: rval\n      });\n    } // optimize away @set\n\n\n    if ('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if (count === 1 && '@language' in rval) {\n    // drop objects with only @language unless custom mapped\n    const mapped = await expansionMap(rval, {\n      unmappedValue: rval,\n      activeCtx,\n      activeProperty,\n      element,\n      options,\n      insideList\n    });\n\n    if (mapped !== undefined) {\n      rval = mapped;\n    } else {\n      rval = null;\n    }\n  } // drop certain top-level objects that do not occur in lists, unless custom\n  // mapped\n\n\n  if (_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === '@graph')) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    if (count === 0 || '@value' in rval || '@list' in rval || count === 1 && '@id' in rval) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n\n      if (mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    }\n  }\n\n  return rval;\n};\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\n\n\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeKey,\n  typeScopedContext,\n  expansionMap\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue; // Figure out if this is the type for a JSON literal\n\n  const isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], {\n    vocab: true\n  }, options) === '@json';\n\n  for (const key of keys) {\n    let value = element[key];\n    let expandedValue; // skip @context\n\n    if (key === '@context') {\n      continue;\n    } // expand property\n\n\n    let expandedProperty = _expandIri(activeCtx, key, {\n      vocab: true\n    }, options); // drop non-absolute IRI keys that aren't keywords unless custom mapped\n\n\n    if (expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      // TODO: use `await` to support async\n      expandedProperty = expansionMap({\n        unmappedProperty: key,\n        activeCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        value,\n        expandedParent\n      });\n\n      if (expandedProperty === undefined) {\n        continue;\n      }\n    }\n\n    if (_isKeyword(expandedProperty)) {\n      if (expandedActiveProperty === '@reverse') {\n        throw new JsonLdError('Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' + 'property.', 'jsonld.SyntaxError', {\n          code: 'invalid reverse property map',\n          value\n        });\n      }\n\n      if (expandedProperty in expandedParent && expandedProperty !== '@included' && expandedProperty !== '@type') {\n        throw new JsonLdError('Invalid JSON-LD syntax; colliding keywords detected.', 'jsonld.SyntaxError', {\n          code: 'colliding keywords',\n          keyword: expandedProperty\n        });\n      }\n    } // syntax error if @id is not a string\n\n\n    if (expandedProperty === '@id') {\n      if (!_isString(value)) {\n        if (!options.isFrame) {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value must a string.', 'jsonld.SyntaxError', {\n            code: 'invalid @id value',\n            value\n          });\n        }\n\n        if (_isObject(value)) {\n          // empty object is a wildcard\n          if (!_isEmptyObject(value)) {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value\n            });\n          }\n        } else if (_isArray(value)) {\n          if (!value.every(v => _isString(v))) {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value\n            });\n          }\n        } else {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n            code: 'invalid @id value',\n            value\n          });\n        }\n      }\n\n      _addValue(expandedParent, '@id', _asArray(value).map(v => _isString(v) ? _expandIri(activeCtx, v, {\n        base: true\n      }, options) : v), {\n        propertyIsArray: options.isFrame\n      });\n\n      continue;\n    }\n\n    if (expandedProperty === '@type') {\n      // if framing, can be a default object, but need to expand\n      // key to determine that\n      if (_isObject(value)) {\n        value = Object.fromEntries(Object.entries(value).map(([k, v]) => [_expandIri(typeScopedContext, k, {\n          vocab: true\n        }), _asArray(v).map(vv => _expandIri(typeScopedContext, vv, {\n          base: true,\n          vocab: true\n        }))]));\n      }\n\n      _validateTypeValue(value, options.isFrame);\n\n      _addValue(expandedParent, '@type', _asArray(value).map(v => _isString(v) ? _expandIri(typeScopedContext, v, {\n        base: true,\n        vocab: true\n      }, options) : v), {\n        propertyIsArray: options.isFrame\n      });\n\n      continue;\n    } // Included blocks are treated as an array of separate object nodes sharing\n    // the same referencing active_property.\n    // For 1.0, it is skipped as are other unknown keywords\n\n\n    if (expandedProperty === '@included' && _processingMode(activeCtx, 1.1)) {\n      const includedResult = _asArray(await api.expand({\n        activeCtx,\n        activeProperty,\n        element: value,\n        options,\n        expansionMap\n      })); // Expanded values must be node objects\n\n\n      if (!includedResult.every(v => _isSubject(v))) {\n        throw new JsonLdError('Invalid JSON-LD syntax; ' + 'values of @included must expand to node objects.', 'jsonld.SyntaxError', {\n          code: 'invalid @included value',\n          value\n        });\n      }\n\n      _addValue(expandedParent, '@included', includedResult, {\n        propertyIsArray: true\n      });\n\n      continue;\n    } // @graph must be an array or an object\n\n\n    if (expandedProperty === '@graph' && !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError('Invalid JSON-LD syntax; \"@graph\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n        code: 'invalid @graph value',\n        value\n      });\n    }\n\n    if (expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n\n      if (isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(expandedParent, '@value', value, {\n          propertyIsArray: options.isFrame\n        });\n      }\n\n      continue;\n    } // @language must be a string\n    // it should match BCP47\n\n\n    if (expandedProperty === '@language') {\n      if (value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n\n      if (!_isString(value) && !options.isFrame) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@language\" value must be a string.', 'jsonld.SyntaxError', {\n          code: 'invalid language-tagged string',\n          value\n        });\n      } // ensure language value is lowercase\n\n\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v); // ensure language tag matches BCP47\n\n      for (const lang of value) {\n        if (_isString(lang) && !lang.match(REGEX_BCP47)) {\n          console.warn(`@language must be valid BCP47: ${lang}`);\n        }\n      }\n\n      _addValue(expandedParent, '@language', value, {\n        propertyIsArray: options.isFrame\n      });\n\n      continue;\n    } // @direction must be \"ltr\" or \"rtl\"\n\n\n    if (expandedProperty === '@direction') {\n      if (!_isString(value) && !options.isFrame) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@direction\" value must be a string.', 'jsonld.SyntaxError', {\n          code: 'invalid base direction',\n          value\n        });\n      }\n\n      value = _asArray(value); // ensure direction is \"ltr\" or \"rtl\"\n\n      for (const dir of value) {\n        if (_isString(dir) && dir !== 'ltr' && dir !== 'rtl') {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".', 'jsonld.SyntaxError', {\n            code: 'invalid base direction',\n            value\n          });\n        }\n      }\n\n      _addValue(expandedParent, '@direction', value, {\n        propertyIsArray: options.isFrame\n      });\n\n      continue;\n    } // @index must be a string\n\n\n    if (expandedProperty === '@index') {\n      if (!_isString(value)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@index\" value must be a string.', 'jsonld.SyntaxError', {\n          code: 'invalid @index value',\n          value\n        });\n      }\n\n      _addValue(expandedParent, '@index', value);\n\n      continue;\n    } // @reverse must be an object\n\n\n    if (expandedProperty === '@reverse') {\n      if (!_isObject(value)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must be an object.', 'jsonld.SyntaxError', {\n          code: 'invalid @reverse value',\n          value\n        });\n      }\n\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty: '@reverse',\n        element: value,\n        options,\n        expansionMap\n      }); // properties double-reversed\n\n      if ('@reverse' in expandedValue) {\n        for (const property in expandedValue['@reverse']) {\n          _addValue(expandedParent, property, expandedValue['@reverse'][property], {\n            propertyIsArray: true\n          });\n        }\n      } // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n\n\n      let reverseMap = expandedParent['@reverse'] || null;\n\n      for (const property in expandedValue) {\n        if (property === '@reverse') {\n          continue;\n        }\n\n        if (reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n\n        _addValue(reverseMap, property, [], {\n          propertyIsArray: true\n        });\n\n        const items = expandedValue[property];\n\n        for (let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n\n          if (_isValue(item) || _isList(item)) {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n              code: 'invalid reverse property value',\n              value: expandedValue\n            });\n          }\n\n          _addValue(reverseMap, property, item, {\n            propertyIsArray: true\n          });\n        }\n      }\n\n      continue;\n    } // nested keys\n\n\n    if (expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    } // use potential scoped context for key\n\n\n    let termCtx = activeCtx;\n\n    const ctx = _getContextValue(activeCtx, key, '@context');\n\n    if (!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(termCtx, key, '@container') || [];\n\n    if (container.includes('@language') && _isObject(value)) {\n      const direction = _getContextValue(termCtx, key, '@direction'); // handle language map container (skip if value is not an object)\n\n\n      expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n    } else if (container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n\n      const propertyIndex = indexKey !== '@index' && _expandIri(activeCtx, indexKey, {\n        vocab: true\n      }, options);\n\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if (container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if (container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = expandedProperty === '@list';\n\n      if (isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n\n        if (isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList,\n          expansionMap\n        });\n      } else if (_getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false,\n          expansionMap\n        });\n      }\n    } // drop null values if property is not @value\n\n\n    if (expandedValue === null && expandedProperty !== '@value') {\n      // TODO: use `await` to support async\n      expandedValue = expansionMap({\n        unmappedValue: value,\n        expandedProperty,\n        activeCtx: termCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        key,\n        expandedParent\n      });\n\n      if (expandedValue === undefined) {\n        continue;\n      }\n    } // convert expanded value to @list if container specifies it\n\n\n    if (expandedProperty !== '@list' && !_isList(expandedValue) && container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {\n        '@list': _asArray(expandedValue)\n      };\n    } // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n\n\n    if (container.includes('@graph') && !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are arrays\n      expandedValue = _asArray(expandedValue).map(v => ({\n        '@graph': _asArray(v)\n      }));\n    } // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n\n\n    if (termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap = expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n\n      for (let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n\n        if (_isValue(item) || _isList(item)) {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n            code: 'invalid reverse property value',\n            value: expandedValue\n          });\n        }\n\n        _addValue(reverseMap, expandedProperty, item, {\n          propertyIsArray: true\n        });\n      }\n\n      continue;\n    } // add value for property\n    // special keywords handled above\n\n\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  } // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n\n\n  if ('@value' in expandedParent) {\n    if (expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {// allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if ((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame) {\n      throw new JsonLdError('Invalid JSON-LD syntax; \"@value\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n        code: 'invalid value object value',\n        value: unexpandedValue\n      });\n    }\n  } // expand each nested key\n\n\n  for (const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n\n    for (const nv of nestedValues) {\n      if (!_isObject(nv) || Object.keys(nv).some(k => _expandIri(activeCtx, k, {\n        vocab: true\n      }, options) === '@value')) {\n        throw new JsonLdError('Invalid JSON-LD syntax; nested value must be a node object.', 'jsonld.SyntaxError', {\n          code: 'invalid @nest value',\n          value: nv\n        });\n      }\n\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeScopedContext,\n        typeKey,\n        expansionMap\n      });\n    }\n  }\n}\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\n\n\nfunction _expandValue({\n  activeCtx,\n  activeProperty,\n  value,\n  options\n}) {\n  // nothing to expand\n  if (value === null || value === undefined) {\n    return null;\n  } // special-case expand @id and @type (skips '@id' expansion)\n\n\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  if (expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {\n      base: true\n    }, options);\n  } else if (expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {\n      vocab: true,\n      base: true\n    }, options);\n  } // get type definition from context\n\n\n  const type = _getContextValue(activeCtx, activeProperty, '@type'); // do @id expansion (automatic for @graph)\n\n\n  if ((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        base: true\n      }, options)\n    };\n  } // do @id expansion w/vocab\n\n\n  if (type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        vocab: true,\n        base: true\n      }, options)\n    };\n  } // do not expand keyword values\n\n\n  if (_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if (type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if (_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    if (language !== null) {\n      rval['@language'] = language;\n    }\n\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n\n    if (direction !== null) {\n      rval['@direction'] = direction;\n    }\n  } // do conversion of values that aren't basic JSON types to strings\n\n\n  if (!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n\n  rval['@value'] = value;\n  return rval;\n}\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\n\n\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n\n  for (const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {\n      vocab: true\n    }, options);\n\n    let val = languageMap[key];\n\n    if (!_isArray(val)) {\n      val = [val];\n    }\n\n    for (const item of val) {\n      if (item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n\n      if (!_isString(item)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; language map values must be strings.', 'jsonld.SyntaxError', {\n          code: 'invalid language map value',\n          languageMap\n        });\n      }\n\n      const val = {\n        '@value': item\n      };\n\n      if (expandedKey !== '@none') {\n        val['@language'] = key.toLowerCase();\n      }\n\n      if (direction) {\n        val['@direction'] = direction;\n      }\n\n      rval.push(val);\n    }\n  }\n\n  return rval;\n}\n\nasync function _expandIndexMap({\n  activeCtx,\n  options,\n  activeProperty,\n  value,\n  expansionMap,\n  asGraph,\n  indexKey,\n  propertyIndex\n}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n\n  for (let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if (isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n\n      if (!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n\n    if (!_isArray(val)) {\n      val = [val];\n    }\n\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true,\n      expansionMap\n    }); // expand for @type, but also for @none\n\n    let expandedKey;\n\n    if (propertyIndex) {\n      if (key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue({\n          activeCtx,\n          activeProperty: indexKey,\n          value: key,\n          options\n        });\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {\n        vocab: true\n      }, options);\n    }\n\n    if (indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {\n        base: true\n      }, options);\n    } else if (isTypeIndex) {\n      key = expandedKey;\n    }\n\n    for (let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if (asGraph && !_isGraph(item)) {\n        item = {\n          '@graph': [item]\n        };\n      }\n\n      if (indexKey === '@type') {\n        if (expandedKey === '@none') {// ignore @none\n        } else if (item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if (_isValue(item) && !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; Attempt to add illegal key to value ' + `object: \"${indexKey}\".`, 'jsonld.SyntaxError', {\n          code: 'invalid value object',\n          value: item\n        });\n      } else if (propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if (expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if (expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n\n      rval.push(item);\n    }\n  }\n\n  return rval;\n}","map":{"version":3,"sources":["/app/node_modules/jsonld/lib/expand.js"],"names":["JsonLdError","require","isArray","_isArray","isObject","_isObject","isEmptyObject","_isEmptyObject","isString","_isString","isUndefined","_isUndefined","isList","_isList","isValue","_isValue","isGraph","_isGraph","isSubject","_isSubject","expandIri","_expandIri","getContextValue","_getContextValue","isKeyword","_isKeyword","process","_processContext","processingMode","_processingMode","isAbsolute","_isAbsoluteIri","addValue","_addValue","asArray","_asArray","getValues","_getValues","validateTypeValue","_validateTypeValue","api","module","exports","REGEX_BCP47","expand","activeCtx","activeProperty","element","options","insideList","insideIndex","typeScopedContext","expansionMap","undefined","Object","assign","isFrame","vocab","mapped","unmappedValue","_expandValue","value","rval","container","includes","i","length","e","parent","index","expandedParent","concat","push","expandedActiveProperty","propertyScopedCtx","previousContext","keys","sort","mustRevert","key","expandedProperty","revertToPreviousContext","localCtx","propagate","overrideProtected","typeKey","types","Array","slice","type","ctx","_expandObject","count","code","validCount","values","every","v","t","indexOf","keepFreeFloatingNodes","nests","unexpandedValue","isJsonType","expandedValue","unmappedProperty","keyword","map","base","propertyIsArray","fromEntries","entries","k","vv","includedResult","toLowerCase","lang","match","console","warn","dir","property","reverseMap","items","ii","item","termCtx","direction","_expandLanguageMap","asGraph","indexKey","propertyIndex","_expandIndexMap","nextActiveProperty","some","mappings","has","get","reverse","nestedValues","nv","language","toString","languageMap","expandedKey","val","isTypeIndex","prependValue"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSubject: _isSubject\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null,\n  expansionMap = () => undefined\n}) => {\n  // nothing to expand\n  if(element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if(activeProperty === '@default') {\n    options = Object.assign({}, options, {isFrame: false});\n  }\n\n  if(!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists unless custom mapped\n    if(!insideList && (activeProperty === null ||\n      _expandIri(activeCtx, activeProperty, {vocab: true},\n        options) === '@graph')) {\n      const mapped = await expansionMap({\n        unmappedValue: element,\n        activeCtx,\n        activeProperty,\n        options,\n        insideList\n      });\n      if(mapped === undefined) {\n        return null;\n      }\n      return mapped;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({activeCtx, activeProperty, value: element, options});\n  }\n\n  // recursively expand array\n  if(_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(\n      activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for(let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        expansionMap,\n        insideIndex,\n        typeScopedContext\n      });\n      if(insideList && _isArray(e)) {\n        e = {'@list': e};\n      }\n\n      if(e === null) {\n        e = await expansionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options,\n          expandedParent: rval,\n          insideList\n        });\n        if(e === undefined) {\n          continue;\n        }\n      }\n\n      if(_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n\n  // Get any property-scoped context for activeProperty\n  const propertyScopedCtx =\n    _getContextValue(activeCtx, activeProperty, '@context');\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext ||\n    (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if(mustRevert && typeScopedContext && keys.length <= 2 &&\n    !keys.includes('@context')) {\n    for(const key of keys) {\n      const expandedProperty = _expandIri(\n        typeScopedContext, key, {vocab: true}, options);\n      if(expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if(expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if(mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  }\n\n  // apply property-scoped context after reverting term-scoped context\n  if(!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // if element has a context, process it\n  if('@context' in element) {\n    activeCtx = await _processContext(\n      {activeCtx, localCtx: element['@context'], options});\n  }\n\n  // set the type-scoped context to the context on input, for use later\n  typeScopedContext = activeCtx;\n\n  // Remember the first key found expanding to @type\n  let typeKey = null;\n\n  // look for scoped contexts on `@type`\n  for(const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types =\n        Array.isArray(value) ?\n          (value.length > 1 ? value.slice().sort() : value) : [value];\n      for(const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n        if(!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeKey,\n    typeScopedContext,\n    expansionMap});\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if('@value' in rval) {\n    // @value must only have @language or @type\n    if('@type' in rval && ('@language' in rval || '@direction' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may not ' +\n        'contain both \"@type\" and either \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    let validCount = count - 1;\n    if('@type' in rval) {\n      validCount -= 1;\n    }\n    if('@index' in rval) {\n      validCount -= 1;\n    }\n    if('@language' in rval) {\n      validCount -= 1;\n    }\n    if('@direction' in rval) {\n      validCount -= 1;\n    }\n    if(validCount !== 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may only ' +\n        'have an \"@index\" property and either \"@type\" ' +\n        'or either or both \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values unless custom mapped\n    if(_processingMode(activeCtx, 1.1) && types.includes('@json') &&\n      types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if(values.length === 0) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    } else if(!values.every(v => (_isString(v) || _isEmptyObject(v))) &&\n      '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; only strings may be language-tagged.',\n        'jsonld.SyntaxError',\n        {code: 'invalid language-tagged value', element: rval});\n    } else if(!types.every(t =>\n      (_isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) ||\n      _isEmptyObject(t)))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' +\n        'must have an absolute IRI for the value of \"@type\".',\n        'jsonld.SyntaxError', {code: 'invalid typed value', element: rval});\n    }\n  } else if('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if(count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; if an element has the property \"@set\" ' +\n        'or \"@list\", then it can have at most one other property that is ' +\n        '\"@index\".', 'jsonld.SyntaxError',\n        {code: 'invalid set or list object', element: rval});\n    }\n    // optimize away @set\n    if('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if(count === 1 && '@language' in rval) {\n    // drop objects with only @language unless custom mapped\n    const mapped = await expansionMap(rval, {\n      unmappedValue: rval,\n      activeCtx,\n      activeProperty,\n      element,\n      options,\n      insideList\n    });\n    if(mapped !== undefined) {\n      rval = mapped;\n    } else {\n      rval = null;\n    }\n  }\n\n  // drop certain top-level objects that do not occur in lists, unless custom\n  // mapped\n  if(_isObject(rval) &&\n    !options.keepFreeFloatingNodes && !insideList &&\n    (activeProperty === null || expandedActiveProperty === '@graph')) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    if(count === 0 || '@value' in rval || '@list' in rval ||\n      (count === 1 && '@id' in rval)) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeKey,\n  typeScopedContext,\n  expansionMap\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue;\n\n  // Figure out if this is the type for a JSON literal\n  const isJsonType = element[typeKey] &&\n    _expandIri(activeCtx,\n      (_isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey]),\n      {vocab: true}, options) === '@json';\n\n  for(const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if(key === '@context') {\n      continue;\n    }\n\n    // expand property\n    let expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n\n    // drop non-absolute IRI keys that aren't keywords unless custom mapped\n    if(expandedProperty === null ||\n      !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      // TODO: use `await` to support async\n      expandedProperty = expansionMap({\n        unmappedProperty: key,\n        activeCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        value,\n        expandedParent\n      });\n      if(expandedProperty === undefined) {\n        continue;\n      }\n    }\n\n    if(_isKeyword(expandedProperty)) {\n      if(expandedActiveProperty === '@reverse') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' +\n          'property.', 'jsonld.SyntaxError',\n          {code: 'invalid reverse property map', value});\n      }\n      if(expandedProperty in expandedParent &&\n         expandedProperty !== '@included' &&\n         expandedProperty !== '@type') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; colliding keywords detected.',\n          'jsonld.SyntaxError',\n          {code: 'colliding keywords', keyword: expandedProperty});\n      }\n    }\n\n    // syntax error if @id is not a string\n    if(expandedProperty === '@id') {\n      if(!_isString(value)) {\n        if(!options.isFrame) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value must a string.',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n        if(_isObject(value)) {\n          // empty object is a wildcard\n          if(!_isEmptyObject(value)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else if(_isArray(value)) {\n          if(!value.every(v => _isString(v))) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n            'of strings, if framing',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@id',\n        _asArray(value).map(v =>\n          _isString(v) ? _expandIri(activeCtx, v, {base: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    if(expandedProperty === '@type') {\n      // if framing, can be a default object, but need to expand\n      // key to determine that\n      if(_isObject(value)) {\n        value = Object.fromEntries(Object.entries(value).map(([k, v]) => [\n          _expandIri(typeScopedContext, k, {vocab: true}),\n          _asArray(v).map(vv =>\n            _expandIri(typeScopedContext, vv, {base: true, vocab: true})\n          )\n        ]));\n      }\n      _validateTypeValue(value, options.isFrame);\n      _addValue(\n        expandedParent, '@type',\n        _asArray(value).map(v =>\n          _isString(v) ?\n            _expandIri(typeScopedContext, v,\n              {base: true, vocab: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // Included blocks are treated as an array of separate object nodes sharing\n    // the same referencing active_property.\n    // For 1.0, it is skipped as are other unknown keywords\n    if(expandedProperty === '@included' && _processingMode(activeCtx, 1.1)) {\n      const includedResult = _asArray(await api.expand({\n        activeCtx,\n        activeProperty,\n        element: value,\n        options,\n        expansionMap\n      }));\n\n      // Expanded values must be node objects\n      if(!includedResult.every(v => _isSubject(v))) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; ' +\n          'values of @included must expand to node objects.',\n          'jsonld.SyntaxError', {code: 'invalid @included value', value});\n      }\n\n      _addValue(\n        expandedParent, '@included', includedResult, {propertyIsArray: true});\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if(expandedProperty === '@graph' &&\n      !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@graph\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError', {code: 'invalid @graph value', value});\n    }\n\n    if(expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n      if(isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(\n          expandedParent, '@value', value, {propertyIsArray: options.isFrame});\n      }\n      continue;\n    }\n\n    // @language must be a string\n    // it should match BCP47\n    if(expandedProperty === '@language') {\n      if(value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@language\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language-tagged string', value});\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      // ensure language tag matches BCP47\n      for(const lang of value) {\n        if(_isString(lang) && !lang.match(REGEX_BCP47)) {\n          console.warn(`@language must be valid BCP47: ${lang}`);\n        }\n      }\n\n      _addValue(\n        expandedParent, '@language', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @direction must be \"ltr\" or \"rtl\"\n    if(expandedProperty === '@direction') {\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@direction\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', value});\n      }\n\n      value = _asArray(value);\n\n      // ensure direction is \"ltr\" or \"rtl\"\n      for(const dir of value) {\n        if(_isString(dir) && dir !== 'ltr' && dir !== 'rtl') {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".',\n            'jsonld.SyntaxError',\n            {code: 'invalid base direction', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@direction', value,\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @index must be a string\n    if(expandedProperty === '@index') {\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@index\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @index value', value});\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if(expandedProperty === '@reverse') {\n      if(!_isObject(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@reverse\" value must be an object.',\n          'jsonld.SyntaxError', {code: 'invalid @reverse value', value});\n      }\n\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty:\n        '@reverse',\n        element: value,\n        options,\n        expansionMap\n      });\n      // properties double-reversed\n      if('@reverse' in expandedValue) {\n        for(const property in expandedValue['@reverse']) {\n          _addValue(\n            expandedParent, property, expandedValue['@reverse'][property],\n            {propertyIsArray: true});\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for(const property in expandedValue) {\n        if(property === '@reverse') {\n          continue;\n        }\n        if(reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {propertyIsArray: true});\n        const items = expandedValue[property];\n        for(let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if(_isValue(item) || _isList(item)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n              '@value or an @list.', 'jsonld.SyntaxError',\n              {code: 'invalid reverse property value', value: expandedValue});\n          }\n          _addValue(reverseMap, property, item, {propertyIsArray: true});\n        }\n      }\n\n      continue;\n    }\n\n    // nested keys\n    if(expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if(!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(termCtx, key, '@container') || [];\n\n    if(container.includes('@language') && _isObject(value)) {\n      const direction = _getContextValue(termCtx, key, '@direction');\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n    } else if(container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n      const propertyIndex = indexKey !== '@index' &&\n        _expandIri(activeCtx, indexKey, {vocab: true}, options);\n\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if(container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if(container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = (expandedProperty === '@list');\n      if(isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if(isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList,\n          expansionMap\n        });\n      } else if(\n        _getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false,\n          expansionMap\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if(expandedValue === null && expandedProperty !== '@value') {\n      // TODO: use `await` to support async\n      expandedValue = expansionMap({\n        unmappedValue: value,\n        expandedProperty,\n        activeCtx: termCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        key,\n        expandedParent\n      });\n      if(expandedValue === undefined) {\n        continue;\n      }\n    }\n\n    // convert expanded value to @list if container specifies it\n    if(expandedProperty !== '@list' && !_isList(expandedValue) &&\n      container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {'@list': _asArray(expandedValue)};\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if(container.includes('@graph') &&\n      !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are arrays\n      expandedValue = _asArray(expandedValue)\n        .map(v => ({'@graph': _asArray(v)}));\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if(termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap =\n        expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for(let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if(_isValue(item) || _isList(item)) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n            '@value or an @list.', 'jsonld.SyntaxError',\n            {code: 'invalid reverse property value', value: expandedValue});\n        }\n        _addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});\n      }\n      continue;\n    }\n\n    // add value for property\n    // special keywords handled above\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if('@value' in expandedParent) {\n    if(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if((_isObject(unexpandedValue) || _isArray(unexpandedValue)) &&\n      !options.isFrame) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@value\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError',\n        {code: 'invalid value object value', value: unexpandedValue});\n    }\n  }\n\n  // expand each nested key\n  for(const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for(const nv of nestedValues) {\n      if(!_isObject(nv) || Object.keys(nv).some(k =>\n        _expandIri(activeCtx, k, {vocab: true}, options) === '@value')) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; nested value must be a node object.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @nest value', value: nv});\n      }\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeScopedContext,\n        typeKey,\n        expansionMap});\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({activeCtx, activeProperty, value, options}) {\n  // nothing to expand\n  if(value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n  if(expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {base: true}, options);\n  } else if(expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {vocab: true, base: true}, options);\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {'@id': _expandIri(activeCtx, value, {base: true}, options)};\n  }\n  // do @id expansion w/vocab\n  if(type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {vocab: true, base: true}, options)\n    };\n  }\n\n  // do not expand keyword values\n  if(_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if(type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if(_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if(language !== null) {\n      rval['@language'] = language;\n    }\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    if(direction !== null) {\n      rval['@direction'] = direction;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if(!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for(const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    let val = languageMap[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n    for(const item of val) {\n      if(item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if(!_isString(item)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; language map values must be strings.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language map value', languageMap});\n      }\n      const val = {'@value': item};\n      if(expandedKey !== '@none') {\n        val['@language'] = key.toLowerCase();\n      }\n      if(direction) {\n        val['@direction'] = direction;\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\n\nasync function _expandIndexMap(\n  {activeCtx, options, activeProperty, value, expansionMap, asGraph,\n    indexKey, propertyIndex}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for(let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if(isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true,\n      expansionMap\n    });\n\n    // expand for @type, but also for @none\n    let expandedKey;\n    if(propertyIndex) {\n      if(key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue(\n          {activeCtx, activeProperty: indexKey, value: key, options});\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    }\n\n    if(indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {base: true}, options);\n    } else if(isTypeIndex) {\n      key = expandedKey;\n    }\n\n    for(let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if(asGraph && !_isGraph(item)) {\n        item = {'@graph': [item]};\n      }\n      if(indexKey === '@type') {\n        if(expandedKey === '@none') {\n          // ignore @none\n        } else if(item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if(_isValue(item) &&\n        !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; Attempt to add illegal key to value ' +\n          `object: \"${indexKey}\".`,\n          'jsonld.SyntaxError',\n          {code: 'invalid value object', value: item});\n      } else if(propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if(expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if(expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}\n"]},"metadata":{},"sourceType":"script"}