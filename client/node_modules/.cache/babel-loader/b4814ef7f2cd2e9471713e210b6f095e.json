{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  createNodeMap\n} = require('./nodeMap');\n\nconst {\n  isKeyword\n} = require('./context');\n\nconst graphTypes = require('./graphTypes');\n\nconst jsonCanonicalize = require('canonicalize');\n\nconst types = require('./types');\n\nconst util = require('./util');\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING\n} = require('./constants');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst api = {};\nmodule.exports = api;\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\n\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {\n    '@default': {}\n  };\n  createNodeMap(input, nodeMap, '@default', issuer);\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n\n  for (const graphName of graphNames) {\n    let graphTerm;\n\n    if (graphName === '@default') {\n      graphTerm = {\n        termType: 'DefaultGraph',\n        value: ''\n      };\n    } else if (_isAbsoluteIri(graphName)) {\n      if (graphName.startsWith('_:')) {\n        graphTerm = {\n          termType: 'BlankNode'\n        };\n      } else {\n        graphTerm = {\n          termType: 'NamedNode'\n        };\n      }\n\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      continue;\n    }\n\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\n\n\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n\n  for (const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n\n    for (let property of properties) {\n      const items = node[property];\n\n      if (property === '@type') {\n        property = RDF_TYPE;\n      } else if (isKeyword(property)) {\n        continue;\n      }\n\n      for (const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        }; // skip relative IRI subjects (not valid RDF)\n\n        if (!_isAbsoluteIri(id)) {\n          continue;\n        } // RDF predicate\n\n\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        }; // skip relative IRI predicates (not valid RDF)\n\n        if (!_isAbsoluteIri(property)) {\n          continue;\n        } // skip blank node predicates unless producing generalized RDF\n\n\n        if (predicate.termType === 'BlankNode' && !options.produceGeneralizedRdf) {\n          continue;\n        } // convert list, value or node object to triple\n\n\n        const object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection); // skip null objects (they are relative IRIs)\n\n\n        if (object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\n\n\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {\n  const first = {\n    termType: 'NamedNode',\n    value: RDF_FIRST\n  };\n  const rest = {\n    termType: 'NamedNode',\n    value: RDF_REST\n  };\n  const nil = {\n    termType: 'NamedNode',\n    value: RDF_NIL\n  };\n  const last = list.pop(); // Result is the head of the list\n\n  const result = last ? {\n    termType: 'BlankNode',\n    value: issuer.getId()\n  } : nil;\n  let subject = result;\n\n  for (const item of list) {\n    const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);\n\n    const next = {\n      termType: 'BlankNode',\n      value: issuer.getId()\n    };\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  } // Tail of list\n\n\n  if (last) {\n    const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);\n\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\n\n\nfunction _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {\n  const object = {}; // convert value object to RDF\n\n  if (graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null; // convert to XSD/JSON datatypes as appropriate\n\n    if (datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if (types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if (!types.isDouble(value)) {\n        value = parseFloat(value);\n      } // canonical double representation\n\n\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if (types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if (rdfDirection === 'i18n-datatype' && '@direction' in item) {\n      const datatype = 'https://www.w3.org/ns/i18n#' + (item['@language'] || '') + `_${item['@direction']}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if ('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if (graphTypes.isList(item)) {\n    const _list = _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);\n\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  } // skip relative IRIs, not valid RDF\n\n\n  if (object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n\n  return object;\n}","map":{"version":3,"sources":["/app/node_modules/jsonld/lib/toRdf.js"],"names":["createNodeMap","require","isKeyword","graphTypes","jsonCanonicalize","types","util","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","RDF_LANGSTRING","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","isAbsolute","_isAbsoluteIri","api","module","exports","toRDF","input","options","issuer","IdentifierIssuer","nodeMap","dataset","graphNames","Object","keys","sort","graphName","graphTerm","termType","value","startsWith","_graphToRDF","graph","ids","id","node","properties","property","items","item","subject","predicate","produceGeneralizedRdf","object","_objectToRDF","rdfDirection","push","_listToRDF","list","first","rest","nil","last","pop","result","getId","next","isValue","undefined","datatype","isBoolean","toString","isDouble","parseFloat","toExponential","replace","isNumber","toFixed","language","isList","_list","isObject"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {createNodeMap} = require('./nodeMap');\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst jsonCanonicalize = require('canonicalize');\nconst types = require('./types');\nconst util = require('./util');\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {'@default': {}};\n  createNodeMap(input, nodeMap, '@default', issuer);\n\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for(const graphName of graphNames) {\n    let graphTerm;\n    if(graphName === '@default') {\n      graphTerm = {termType: 'DefaultGraph', value: ''};\n    } else if(_isAbsoluteIri(graphName)) {\n      if(graphName.startsWith('_:')) {\n        graphTerm = {termType: 'BlankNode'};\n      } else {\n        graphTerm = {termType: 'NamedNode'};\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for(const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for(let property of properties) {\n      const items = node[property];\n      if(property === '@type') {\n        property = RDF_TYPE;\n      } else if(isKeyword(property)) {\n        continue;\n      }\n\n      for(const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if(!_isAbsoluteIri(id)) {\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if(!_isAbsoluteIri(property)) {\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if(predicate.termType === 'BlankNode' &&\n          !options.produceGeneralizedRdf) {\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object =\n          _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection);\n        // skip null objects (they are relative IRIs)\n        if(object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {\n  const first = {termType: 'NamedNode', value: RDF_FIRST};\n  const rest = {termType: 'NamedNode', value: RDF_REST};\n  const nil = {termType: 'NamedNode', value: RDF_NIL};\n\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {termType: 'BlankNode', value: issuer.getId()} : nil;\n  let subject = result;\n\n  for(const item of list) {\n    const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);\n    const next = {termType: 'BlankNode', value: issuer.getId()};\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if(last) {\n    const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {\n  const object = {};\n\n  // convert value object to RDF\n  if(graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if(datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if(types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if(types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if(!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if(types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if(rdfDirection === 'i18n-datatype' &&\n      '@direction' in item) {\n      const datatype = 'https://www.w3.org/ns/i18n#' +\n        (item['@language'] || '') +\n        `_${item['@direction']}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if(graphTypes.isList(item)) {\n    const _list =\n      _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if(object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n\n  return object;\n}\n"]},"metadata":{},"sourceType":"script"}