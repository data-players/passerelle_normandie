{"ast":null,"code":"/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst graphTypes = require('./graphTypes');\n\nconst types = require('./types'); // TODO: move `IdentifierIssuer` to its own package\n\n\nconst IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;\n\nconst JsonLdError = require('./JsonLdError'); // constants\n\n\nconst REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nconst REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nconst REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\nconst DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\nconst api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\n\napi.clone = function (value) {\n  if (value && typeof value === 'object') {\n    let rval;\n\n    if (types.isArray(value)) {\n      rval = [];\n\n      for (let i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if (value instanceof Map) {\n      rval = new Map();\n\n      for (const [k, v] of value) {\n        rval.set(k, api.clone(v));\n      }\n    } else if (value instanceof Set) {\n      rval = new Set();\n\n      for (const v of value) {\n        rval.add(api.clone(v));\n      }\n    } else if (types.isObject(value)) {\n      rval = {};\n\n      for (const key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n\n    return rval;\n  }\n\n  return value;\n};\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\n\n\napi.asArray = function (value) {\n  return Array.isArray(value) ? value : [value];\n};\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\n\n\napi.buildHeaders = (headers = {}) => {\n  const hasAccept = Object.keys(headers).some(h => h.toLowerCase() === 'accept');\n\n  if (hasAccept) {\n    throw new RangeError('Accept header may not be specified; only \"' + DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({\n    Accept: DEFAULTS.headers.accept\n  }, headers);\n};\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\n\n\napi.parseLinkHeader = header => {\n  const rval = {}; // split on unbracketed/unquoted commas\n\n  const entries = header.match(REGEX_LINK_HEADERS);\n\n  for (let i = 0; i < entries.length; ++i) {\n    let match = entries[i].match(REGEX_LINK_HEADER);\n\n    if (!match) {\n      continue;\n    }\n\n    const result = {\n      target: match[1]\n    };\n    const params = match[2];\n\n    while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {\n      result[match[1]] = match[2] === undefined ? match[3] : match[2];\n    }\n\n    const rel = result['rel'] || '';\n\n    if (Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if (rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n\n  return rval;\n};\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\n\n\napi.validateTypeValue = (v, isFrame) => {\n  if (types.isString(v)) {\n    return;\n  }\n\n  if (types.isArray(v) && v.every(vv => types.isString(vv))) {\n    return;\n  }\n\n  if (isFrame && types.isObject(v)) {\n    switch (Object.keys(v).length) {\n      case 0:\n        // empty object is wildcard\n        return;\n\n      case 1:\n        // default entry is all strings\n        if ('@default' in v && api.asArray(v['@default']).every(vv => types.isString(vv))) {\n          return;\n        }\n\n    }\n  }\n\n  throw new JsonLdError('Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' + 'strings, an empty object, ' + 'or a default object.', 'jsonld.SyntaxError', {\n    code: 'invalid type value',\n    value: v\n  });\n};\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\n\n\napi.hasProperty = (subject, property) => {\n  if (subject.hasOwnProperty(property)) {\n    const value = subject[property];\n    return !types.isArray(value) || value.length > 0;\n  }\n\n  return false;\n};\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\n\n\napi.hasValue = (subject, property, value) => {\n  if (api.hasProperty(subject, property)) {\n    let val = subject[property];\n    const isList = graphTypes.isList(val);\n\n    if (types.isArray(val) || isList) {\n      if (isList) {\n        val = val['@list'];\n      }\n\n      for (let i = 0; i < val.length; ++i) {\n        if (api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if (!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n\n  return false;\n};\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\n\n\napi.addValue = (subject, property, value, options) => {\n  options = options || {};\n\n  if (!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  if (!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n\n  if (!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n\n  if (!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n\n  if (options.valueIsArray) {\n    subject[property] = value;\n  } else if (types.isArray(value)) {\n    if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n\n    if (options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n\n    for (let i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if (subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    const hasValue = !options.allowDuplicate && api.hasValue(subject, property, value); // make property an array if value not present or always an array\n\n    if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    } // add new value\n\n\n    if (!hasValue) {\n      if (options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\n\n\napi.getValues = (subject, property) => [].concat(subject[property] || []);\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\n\n\napi.removeProperty = (subject, property) => {\n  delete subject[property];\n};\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\n\n\napi.removeValue = (subject, property, value, options) => {\n  options = options || {};\n\n  if (!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  } // filter out value\n\n\n  const values = api.getValues(subject, property).filter(e => !api.compareValues(e, value));\n\n  if (values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if (values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\n\n\napi.relabelBlankNodes = (input, options) => {\n  options = options || {};\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\n\n\napi.compareValues = (v1, v2) => {\n  // 1. equal primitives\n  if (v1 === v2) {\n    return true;\n  } // 2. equal @values\n\n\n  if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1['@value'] === v2['@value'] && v1['@type'] === v2['@type'] && v1['@language'] === v2['@language'] && v1['@index'] === v2['@index']) {\n    return true;\n  } // 3. equal @ids\n\n\n  if (types.isObject(v1) && '@id' in v1 && types.isObject(v2) && '@id' in v2) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\n\n\napi.compareShortestLeast = (a, b) => {\n  if (a.length < b.length) {\n    return -1;\n  }\n\n  if (b.length < a.length) {\n    return 1;\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  return a < b ? -1 : 1;\n};\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\n\n\nfunction _labelBlankNodes(issuer, element) {\n  if (types.isArray(element)) {\n    for (let i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if (graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if (types.isObject(element)) {\n    // relabel blank node\n    if (graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    } // recursively apply to all keys\n\n\n    const keys = Object.keys(element).sort();\n\n    for (let ki = 0; ki < keys.length; ++ki) {\n      const key = keys[ki];\n\n      if (key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}","map":{"version":3,"sources":["/app/node_modules/jsonld/lib/util.js"],"names":["graphTypes","require","types","IdentifierIssuer","JsonLdError","REGEX_LINK_HEADERS","REGEX_LINK_HEADER","REGEX_LINK_HEADER_PARAMS","DEFAULTS","headers","accept","api","module","exports","clone","value","rval","isArray","i","length","Map","k","v","set","Set","add","isObject","key","toString","asArray","Array","buildHeaders","hasAccept","Object","keys","some","h","toLowerCase","RangeError","assign","Accept","parseLinkHeader","header","entries","match","result","target","params","exec","undefined","rel","push","hasOwnProperty","validateTypeValue","isFrame","isString","every","vv","code","hasProperty","subject","property","hasValue","val","isList","compareValues","addValue","options","propertyIsArray","valueIsArray","allowDuplicate","prependValue","concat","unshift","getValues","removeProperty","removeValue","values","filter","e","relabelBlankNodes","input","issuer","_labelBlankNodes","v1","v2","isValue","compareShortestLeast","a","b","element","isBlankNode","getId","sort","ki"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\n// TODO: move `IdentifierIssuer` to its own package\nconst IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\n\n// constants\nconst REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nconst REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nconst REGEX_LINK_HEADER_PARAMS =\n  /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\n\nconst DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\n\nconst api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\n\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\napi.clone = function(value) {\n  if(value && typeof value === 'object') {\n    let rval;\n    if(types.isArray(value)) {\n      rval = [];\n      for(let i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if(value instanceof Map) {\n      rval = new Map();\n      for(const [k, v] of value) {\n        rval.set(k, api.clone(v));\n      }\n    } else if(value instanceof Set) {\n      rval = new Set();\n      for(const v of value) {\n        rval.add(api.clone(v));\n      }\n    } else if(types.isObject(value)) {\n      rval = {};\n      for(const key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n    return rval;\n  }\n  return value;\n};\n\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\napi.asArray = function(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\napi.buildHeaders = (headers = {}) => {\n  const hasAccept = Object.keys(headers).some(\n    h => h.toLowerCase() === 'accept');\n\n  if(hasAccept) {\n    throw new RangeError(\n      'Accept header may not be specified; only \"' +\n      DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({Accept: DEFAULTS.headers.accept}, headers);\n};\n\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\napi.parseLinkHeader = header => {\n  const rval = {};\n  // split on unbracketed/unquoted commas\n  const entries = header.match(REGEX_LINK_HEADERS);\n  for(let i = 0; i < entries.length; ++i) {\n    let match = entries[i].match(REGEX_LINK_HEADER);\n    if(!match) {\n      continue;\n    }\n    const result = {target: match[1]};\n    const params = match[2];\n    while((match = REGEX_LINK_HEADER_PARAMS.exec(params))) {\n      result[match[1]] = (match[2] === undefined) ? match[3] : match[2];\n    }\n    const rel = result['rel'] || '';\n    if(Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if(rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n  return rval;\n};\n\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\napi.validateTypeValue = (v, isFrame) => {\n  if(types.isString(v)) {\n    return;\n  }\n\n  if(types.isArray(v) && v.every(vv => types.isString(vv))) {\n    return;\n  }\n  if(isFrame && types.isObject(v)) {\n    switch(Object.keys(v).length) {\n      case 0:\n        // empty object is wildcard\n        return;\n      case 1:\n        // default entry is all strings\n        if('@default' in v &&\n          api.asArray(v['@default']).every(vv => types.isString(vv))) {\n          return;\n        }\n    }\n  }\n\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' +\n    'strings, an empty object, ' +\n    'or a default object.', 'jsonld.SyntaxError',\n    {code: 'invalid type value', value: v});\n};\n\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\napi.hasProperty = (subject, property) => {\n  if(subject.hasOwnProperty(property)) {\n    const value = subject[property];\n    return (!types.isArray(value) || value.length > 0);\n  }\n  return false;\n};\n\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\napi.hasValue = (subject, property, value) => {\n  if(api.hasProperty(subject, property)) {\n    let val = subject[property];\n    const isList = graphTypes.isList(val);\n    if(types.isArray(val) || isList) {\n      if(isList) {\n        val = val['@list'];\n      }\n      for(let i = 0; i < val.length; ++i) {\n        if(api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if(!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n  return false;\n};\n\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\napi.addValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n  if(!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n  if(!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n  if(!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n\n  if(options.valueIsArray) {\n    subject[property] = value;\n  } else if(types.isArray(value)) {\n    if(value.length === 0 && options.propertyIsArray &&\n      !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n    if(options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n    for(let i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if(subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    const hasValue = (!options.allowDuplicate &&\n      api.hasValue(subject, property, value));\n\n    // make property an array if value not present or always an array\n    if(!types.isArray(subject[property]) &&\n      (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    }\n\n    // add new value\n    if(!hasValue) {\n      if(options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\napi.getValues = (subject, property) => [].concat(subject[property] || []);\n\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\napi.removeProperty = (subject, property) => {\n  delete subject[property];\n};\n\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\napi.removeValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  // filter out value\n  const values = api.getValues(subject, property).filter(\n    e => !api.compareValues(e, value));\n\n  if(values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if(values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\napi.relabelBlankNodes = (input, options) => {\n  options = options || {};\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\napi.compareValues = (v1, v2) => {\n  // 1. equal primitives\n  if(v1 === v2) {\n    return true;\n  }\n\n  // 2. equal @values\n  if(graphTypes.isValue(v1) && graphTypes.isValue(v2) &&\n    v1['@value'] === v2['@value'] &&\n    v1['@type'] === v2['@type'] &&\n    v1['@language'] === v2['@language'] &&\n    v1['@index'] === v2['@index']) {\n    return true;\n  }\n\n  // 3. equal @ids\n  if(types.isObject(v1) &&\n    ('@id' in v1) &&\n    types.isObject(v2) &&\n    ('@id' in v2)) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\napi.compareShortestLeast = (a, b) => {\n  if(a.length < b.length) {\n    return -1;\n  }\n  if(b.length < a.length) {\n    return 1;\n  }\n  if(a === b) {\n    return 0;\n  }\n  return (a < b) ? -1 : 1;\n};\n\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\nfunction _labelBlankNodes(issuer, element) {\n  if(types.isArray(element)) {\n    for(let i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if(graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if(types.isObject(element)) {\n    // relabel blank node\n    if(graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    }\n\n    // recursively apply to all keys\n    const keys = Object.keys(element).sort();\n    for(let ki = 0; ki < keys.length; ++ki) {\n      const key = keys[ki];\n      if(key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}\n"]},"metadata":{},"sourceType":"script"}