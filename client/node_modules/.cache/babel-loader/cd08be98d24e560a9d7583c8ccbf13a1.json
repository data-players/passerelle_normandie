{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\n\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if (_isArray(element)) {\n    let rval = [];\n\n    for (let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n\n      if (compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n\n        if (compacted === undefined) {\n          continue;\n        }\n      }\n\n      rval.push(compacted);\n    }\n\n    if (options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n      if (container.length === 0) {\n        rval = rval[0];\n      }\n    }\n\n    return rval;\n  } // use any scoped context on activeProperty\n\n\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n\n  if (!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  } // recursively compact object\n\n\n  if (_isObject(element)) {\n    if (options.link && '@id' in element && options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n\n      for (let i = 0; i < linked.length; ++i) {\n        if (linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    } // do value compaction on @values and subject references\n\n\n    if (_isValue(element) || _isSubjectReference(element)) {\n      const rval = api.compactValue({\n        activeCtx,\n        activeProperty,\n        value: element,\n        options\n      });\n\n      if (options.link && _isSubjectReference(element)) {\n        // store linked element\n        if (!options.link.hasOwnProperty(element['@id'])) {\n          options.link[element['@id']] = [];\n        }\n\n        options.link[element['@id']].push({\n          expanded: element,\n          compacted: rval\n        });\n      }\n\n      return rval;\n    } // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n\n\n    if (_isList(element)) {\n      const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n      if (container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    } // FIXME: avoid misuse of active property as an expanded property?\n\n\n    const insideReverse = activeProperty === '@reverse';\n    const rval = {}; // original context before applying property-scoped and local contexts\n\n    const inputCtx = activeCtx; // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n\n    if (!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    } // apply property-scoped context after reverting term-scoped context\n\n\n    const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');\n\n    if (!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if (options.link && '@id' in element) {\n      // store linked element\n      if (!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n\n      options.link[element['@id']].push({\n        expanded: element,\n        compacted: rval\n      });\n    } // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n\n\n    let types = element['@type'] || [];\n\n    if (types.length > 1) {\n      types = Array.from(types).sort();\n    } // find all type-scoped contexts based on current context, prior to\n    // updating it\n\n\n    const typeContext = activeCtx;\n\n    for (const type of types) {\n      const compactedType = api.compactIri({\n        activeCtx: typeContext,\n        iri: type,\n        relativeTo: {\n          vocab: true\n        }\n      }); // Use any type-scoped context defined on this value\n\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n\n      if (!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    } // process element keys in order\n\n\n    const keys = Object.keys(element).sort();\n\n    for (const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty]; // compact @id\n\n      if (expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(expandedIri => api.compactIri({\n          activeCtx,\n          iri: expandedIri,\n          relativeTo: {\n            vocab: false\n          },\n          base: options.base\n        }));\n\n        if (compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        } // use keyword alias and add value\n\n\n        const alias = api.compactIri({\n          activeCtx,\n          iri: '@id',\n          relativeTo: {\n            vocab: true\n          }\n        });\n        rval[alias] = compactedValue;\n        continue;\n      } // compact @type(s)\n\n\n      if (expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(expandedIri => api.compactIri({\n          activeCtx: inputCtx,\n          iri: expandedIri,\n          relativeTo: {\n            vocab: true\n          }\n        }));\n\n        if (compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        } // use keyword alias and add value\n\n\n        const alias = api.compactIri({\n          activeCtx,\n          iri: '@type',\n          relativeTo: {\n            vocab: true\n          }\n        });\n        const container = _getContextValue(activeCtx, alias, '@container') || []; // treat as array for @type if @container includes @set\n\n        const typeAsSet = container.includes('@set') && _processingMode(activeCtx, 1.1);\n\n        const isArray = typeAsSet || _isArray(compactedValue) && expandedValue.length === 0;\n\n        _addValue(rval, alias, compactedValue, {\n          propertyIsArray: isArray\n        });\n\n        continue;\n      } // handle @reverse\n\n\n      if (expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        }); // handle double-reversed properties\n\n        for (const compactedProperty in compactedValue) {\n          if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n            const useArray = container.includes('@set') || !options.compactArrays;\n\n            _addValue(rval, compactedProperty, value, {\n              propertyIsArray: useArray\n            });\n\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if (Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if (expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if (!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n\n        continue;\n      } // handle @index property\n\n\n      if (expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n        if (container.includes('@index')) {\n          continue;\n        } // use keyword alias and add value\n\n\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {\n            vocab: true\n          }\n        });\n\n        _addValue(rval, alias, expandedValue);\n\n        continue;\n      } // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n\n\n      if (expandedProperty !== '@graph' && expandedProperty !== '@list' && expandedProperty !== '@included' && _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {\n            vocab: true\n          }\n        });\n\n        _addValue(rval, alias, expandedValue);\n\n        continue;\n      } // Note: expanded value must be an array due to expansion algorithm.\n\n\n      if (!_isArray(expandedValue)) {\n        throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n      } // preserve empty arrays\n\n\n      if (expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {\n            vocab: true\n          },\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n\n        if (nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n\n          if (!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n\n          nestResult = rval[nestProperty];\n        }\n\n        _addValue(nestResult, itemActiveProperty, expandedValue, {\n          propertyIsArray: true\n        });\n      } // recusively process array values\n\n\n      for (const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {\n            vocab: true\n          },\n          reverse: insideReverse\n        }); // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n\n        if (nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n\n          if (!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(activeCtx, itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate\n\n        const isGraph = _isGraph(expandedItem);\n\n        const isList = _isList(expandedItem);\n\n        let inner;\n\n        if (isList) {\n          inner = expandedItem['@list'];\n        } else if (isGraph) {\n          inner = expandedItem['@graph'];\n        } // recursively compact expanded item\n\n\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: isList || isGraph ? inner : expandedItem,\n          options,\n          compactionMap\n        }); // handle @list\n\n        if (isList) {\n          // ensure @list value is an array\n          if (!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if (!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {\n                  vocab: true\n                }\n              })]: compactedItem\n            }; // include @index from expanded @list, if any\n\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n\n            continue;\n          }\n        } // Graph object compaction cases\n\n\n        if (isGraph) {\n          if (container.includes('@graph') && (container.includes('@id') || container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n\n            if (nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            } // index on @id or @index or alias of @none\n\n\n            const key = (container.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n              activeCtx,\n              iri: '@none',\n              relativeTo: {\n                vocab: true\n              }\n            }); // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(mapObject, key, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          } else if (container.includes('@graph') && _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if (_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {\n                '@included': compactedItem\n              };\n            }\n\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {\n                  vocab: true\n                }\n              })]: compactedItem\n            }; // include @id from expanded graph, if any\n\n            if ('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@id'];\n            } // include @index from expanded graph, if any\n\n\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          }\n        } else if (container.includes('@language') || container.includes('@index') || container.includes('@id') || container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n\n          if (nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n\n          if (container.includes('@language')) {\n            // if container is a language map, simplify compacted value to\n            // a simple string\n            if (_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n\n            key = expandedItem['@language'];\n          } else if (container.includes('@index')) {\n            const indexKey = _getContextValue(activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri({\n              activeCtx,\n              iri: indexKey,\n              relativeTo: {\n                vocab: true\n              }\n            });\n\n            if (indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n\n              if (!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch (others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if (container.includes('@id')) {\n            const idKey = api.compactIri({\n              activeCtx,\n              iri: '@id',\n              relativeTo: {\n                vocab: true\n              }\n            });\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if (container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {\n                vocab: true\n              }\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n\n            switch (types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            } // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n\n\n            if (Object.keys(compactedItem).length === 1 && '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {\n                  '@id': expandedItem['@id']\n                },\n                options,\n                compactionMap\n              });\n            }\n          } // if compacting this value which has no key, index on @none\n\n\n          if (!key) {\n            key = api.compactIri({\n              activeCtx,\n              iri: '@none',\n              relativeTo: {\n                vocab: true\n              }\n            });\n          } // add compact value to map object using key from expanded value\n          // based on the container type\n\n\n          _addValue(mapObject, key, compactedItem, {\n            propertyIsArray: container.includes('@set')\n          });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = !options.compactArrays || container.includes('@set') || container.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value\n\n          _addValue(nestResult, itemActiveProperty, compactedItem, {\n            propertyIsArray: isArray\n          });\n        }\n      }\n    }\n\n    return rval;\n  } // only primitives remain which are already compact\n\n\n  return element;\n};\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\n\n\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {\n    vocab: false\n  },\n  reverse = false,\n  base = null\n}) => {\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  } // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n\n\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse(); // if term is a keyword, it may be compacted to a simple alias\n\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  } // use inverse context to pick a term if iri is relative to vocab\n\n\n  if (relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none'; // prefer @index if available in value\n\n    const containers = [];\n\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    } // if value is a preserve object, use its value\n\n\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    } // prefer most specific container including @graph, prefering @set\n    // variations\n\n\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // favor idmap if the graph is has an @id\n\n\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n\n      containers.push('@graph', '@graph@set', '@set'); // allow indexmap if the graph is not indexed\n\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // allow idmap if the graph does not have an @id\n\n\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    } // defaults for term selection based on type/language\n\n\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n\n      const list = value['@list'];\n\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = list.length === 0 ? defaultLanguage : null;\n        let commonType = null;\n\n        for (let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n\n          if (_isValue(item)) {\n            if ('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if ('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          } // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n\n\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n\n          if (dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if ('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n\n      containers.push('@set');\n    } // do term selection\n\n\n    containers.push('@none'); // an index map can be used to index values using @none, so add as a low\n    // priority\n\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    } // values without type or language can use @language map\n\n\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n\n    if (term !== null) {\n      return term;\n    }\n  } // no term match, use @vocab if available\n\n\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  } // no term or @vocab match, check for possible CURIEs\n\n\n  let choice = null; // TODO: make FastCurieMap a class with a method to do this lookup\n\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap; // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n\n  const maxPartialLength = iri.length - 1;\n\n  for (let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  } // check partial matches in reverse order to prefer longest ones first\n\n\n  for (let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n\n    for (const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri); // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n\n      if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  } // return chosen curie\n\n\n  if (choice !== null) {\n    return choice;\n  } // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n\n\n  for (const [term, td] of activeCtx.mappings) {\n    if (td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(`Absolute IRI \"${iri}\" confused with prefix \"${term}\".`, 'jsonld.SyntaxError', {\n        code: 'IRI confused with prefix',\n        context: activeCtx\n      });\n    }\n  } // compact IRI relative to base\n\n\n  if (!relativeTo.vocab) {\n    if ('@base' in activeCtx) {\n      if (!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  } // return IRI as is\n\n\n  return iri;\n};\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\n\n\napi.compactValue = ({\n  activeCtx,\n  activeProperty,\n  value,\n  options\n}) => {\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n\n    const container = _getContextValue(activeCtx, activeProperty, '@container') || []; // whether or not the value has an @index that must be preserved\n\n    const preserveIndex = '@index' in value && !container.includes('@index'); // if there's no @index to preserve ...\n\n    if (!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === type) {\n        return value['@value'];\n      }\n\n      if ('@language' in value && value['@language'] === language && '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n\n      if ('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n\n      if ('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    } // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n\n\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    const hasDefaultLanguage = ('@language' in activeCtx);\n\n    const isValueString = _isString(value['@value']);\n\n    const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n\n    if (isValueOnlyKey && type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {}; // preserve @index\n\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    }\n\n    if ('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@direction'];\n    } // alias @value\n\n\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  } // value is a subject reference\n\n\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    },\n    base: options.base\n  }); // compact to scalar\n\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    })]: compacted\n  };\n};\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\n\n\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  } // preferences for the value of @type or @language\n\n\n  const prefs = []; // determine prefs for @id based on whether or not value compacts to a term\n\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    } // try to compact value to a term\n\n\n    const term = api.compactIri({\n      activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue); // consider direction only\n\n    const langDir = prefs.find(el => el.includes('_'));\n\n    if (langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n\n  prefs.push('@none');\n  const containerMap = activeCtx.inverse[iri];\n\n  for (const container of containers) {\n    // if container not available in the map, continue\n    if (!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n\n    for (const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if (!(pref in typeOrLanguageValueMap)) {\n        continue;\n      } // select term\n\n\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\n\n\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":{"version":3,"sources":["/app/node_modules/jsonld/lib/compact.js"],"names":["JsonLdError","require","isArray","_isArray","isObject","_isObject","isString","_isString","isUndefined","_isUndefined","isList","_isList","isValue","_isValue","isGraph","_isGraph","isSimpleGraph","_isSimpleGraph","isSubjectReference","_isSubjectReference","expandIri","_expandIri","getContextValue","_getContextValue","isKeyword","_isKeyword","process","_processContext","processingMode","_processingMode","removeBase","_removeBase","prependBase","_prependBase","addValue","_addValue","asArray","_asArray","compareShortestLeast","_compareShortestLeast","api","module","exports","compact","activeCtx","activeProperty","element","options","compactionMap","undefined","rval","i","length","compacted","unmappedValue","parent","index","push","compactArrays","container","ctx","localCtx","propagate","overrideProtected","link","hasOwnProperty","linked","expanded","compactValue","value","includes","insideReverse","inputCtx","revertToPreviousContext","propertyScopedCtx","types","Array","from","sort","typeContext","type","compactedType","compactIri","iri","relativeTo","vocab","keys","Object","expandedProperty","expandedValue","compactedValue","map","expandedIri","base","alias","typeAsSet","propertyIsArray","compactedProperty","mappings","has","get","reverse","useArray","itemActiveProperty","nestProperty","nestResult","_checkNestProperty","expandedItem","inner","compactedItem","valueIsArray","allowDuplicate","mapObject","key","indexKey","containerKey","others","idKey","typeKey","isPropertyTermScoped","previousContext","inverseCtx","getInverse","defaultLanguage","containers","typeOrLanguage","typeOrLanguageValue","list","commonLanguage","commonType","item","itemLanguage","itemType","lang","toLowerCase","dir","term","_selectTerm","indexOf","suffix","substr","choice","partialMatches","iriMap","fastCurieMap","maxPartialLength","entry","terms","curie","isUsableCurie","_prefix","td","startsWith","code","context","language","direction","preserveIndex","keyCount","isValueOnlyKey","hasDefaultLanguage","isValueString","hasNullMapping","prefs","apply","langDir","find","el","replace","containerMap","inverse","typeOrLanguageValueMap","pref"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false},\n            base: options.base\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        expandedProperty !== '@included' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none',\n                relativeTo: {vocab: true}});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, relativeTo: {vocab: true}});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id',\n              relativeTo: {vocab: true}});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {vocab: true}\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none',\n              relativeTo: {vocab: true}});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false,\n  base = null\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n          if(dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    if('@base' in activeCtx) {\n      if(!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language &&\n         '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    if('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {vocab: true}\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {vocab: type === '@vocab'},\n    base: options.base});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    const langDir = prefs.find(el => el.includes('_'));\n    if(langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n"]},"metadata":{},"sourceType":"script"}