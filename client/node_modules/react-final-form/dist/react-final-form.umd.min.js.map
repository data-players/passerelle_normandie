{"version":3,"file":"react-final-form.umd.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../src/renderComponent.js","../src/useWhenValueChanges.js","../src/shallowEqual.js","../src/isSyntheticEvent.js","../src/context.js","../src/useLatest.js","../src/getters.js","../src/ReactFinalForm.js","../src/useConstant.js","../src/useForm.js","../src/useFormState.js","../src/FormSpy.js","../src/useField.js","../src/isReactNative.js","../src/getValue.js","../src/Field.js","../src/index.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","// @flow\nimport * as React from 'react'\nimport type { RenderableProps } from './types'\n\n// shared logic between components that use either render prop,\n// children render function, or component prop\nexport default function renderComponent<T>(\n  props: RenderableProps<T> & T,\n  lazyProps: Object,\n  name: string\n): React.Node {\n  const { render, children, component, ...rest } = props\n  if (component) {\n    return React.createElement(\n      component,\n      Object.assign(lazyProps, rest, {\n        children,\n        render\n      })\n    )\n  }\n  if (render) {\n    return render(\n      children === undefined\n        ? Object.assign(lazyProps, rest)\n        : // inject children back in\n          Object.assign(lazyProps, rest, { children })\n    )\n  }\n  if (typeof children !== 'function') {\n    throw new Error(\n      `Must specify either a render prop, a render function as children, or a component prop to ${name}`\n    )\n  }\n  return children(Object.assign(lazyProps, rest))\n}\n","// @flow\nimport React from 'react'\n\nexport default function useWhenValueChanges(\n  value: any,\n  callback: () => void,\n  isEqual: (any, any) => boolean = (a, b) => a === b\n) {\n  const previous = React.useRef(value)\n  React.useEffect(() => {\n    if (!isEqual(value, previous.current)) {\n      callback()\n      previous.current = value\n    }\n  })\n}\n","// @flow\nconst shallowEqual = (a: any, b: any): boolean => {\n  if (a === b) {\n    return true\n  }\n  if (typeof a !== 'object' || !a || typeof b !== 'object' || !b) {\n    return false\n  }\n  var keysA = Object.keys(a)\n  var keysB = Object.keys(b)\n  if (keysA.length !== keysB.length) {\n    return false\n  }\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(b)\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx]\n    if (!bHasOwnProperty(key) || a[key] !== b[key]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport default shallowEqual\n","// @flow\nconst isSyntheticEvent = (candidate: any): boolean =>\n  !!(candidate && typeof candidate.stopPropagation === 'function')\n\nexport default isSyntheticEvent\n","// @flow\nimport * as React from 'react'\nimport type { FormApi } from 'final-form'\n\nexport default React.createContext<?FormApi<any>>()\n","// @flow\nimport React from 'react'\n\nexport default function useLatest<T>(value: T): { +current: T } {\n  const ref = React.useRef(value)\n\n  React.useEffect(() => {\n    ref.current = value\n  })\n\n  return ref\n}\n","import type { FormState, FieldState } from 'final-form'\n\nconst addLazyState = (dest: Object, state: Object, keys: string[]): void => {\n  keys.forEach(key => {\n    Object.defineProperty(dest, key, {\n      get: () => state[key],\n      enumerable: true\n    })\n  })\n}\n\nexport const addLazyFormState = (dest: Object, state: FormState): void =>\n  addLazyState(dest, state, [\n    'active',\n    'dirty',\n    'dirtyFields',\n    'dirtySinceLastSubmit',\n    'dirtyFieldsSinceLastSubmit',\n    'error',\n    'errors',\n    'hasSubmitErrors',\n    'hasValidationErrors',\n    'initialValues',\n    'invalid',\n    'modified',\n    'modifiedSinceLastSubmit',\n    'pristine',\n    'submitError',\n    'submitErrors',\n    'submitFailed',\n    'submitSucceeded',\n    'submitting',\n    'touched',\n    'valid',\n    'validating',\n    'values',\n    'visited'\n  ])\n\nexport const addLazyFieldMetaState = (dest: Object, state: FieldState): void =>\n  addLazyState(dest, state, [\n    'active',\n    'data',\n    'dirty',\n    'dirtySinceLastSubmit',\n    'error',\n    'initial',\n    'invalid',\n    'length',\n    'modified',\n    'modifiedSinceLastSubmit',\n    'pristine',\n    'submitError',\n    'submitFailed',\n    'submitSucceeded',\n    'submitting',\n    'touched',\n    'valid',\n    'validating',\n    'visited'\n  ])\n","// @flow\nimport * as React from 'react'\nimport {\n  createForm,\n  formSubscriptionItems,\n  version as ffVersion\n} from 'final-form'\nimport type {\n  FormApi,\n  Config,\n  FormSubscription,\n  FormState,\n  FormValuesShape,\n  Unsubscribe\n} from 'final-form'\nimport type { FormProps as Props, SubmitEvent } from './types'\nimport renderComponent from './renderComponent'\nimport useWhenValueChanges from './useWhenValueChanges'\nimport useConstant from './useConstant'\nimport shallowEqual from './shallowEqual'\nimport isSyntheticEvent from './isSyntheticEvent'\nimport type { FormRenderProps } from './types.js.flow'\nimport ReactFinalFormContext from './context'\nimport useLatest from './useLatest'\nimport { version } from '../package.json'\nimport { addLazyFormState } from './getters'\n\nexport { version }\n\nconst versions = {\n  'final-form': ffVersion,\n  'react-final-form': version\n}\n\nexport const all: FormSubscription = formSubscriptionItems.reduce(\n  (result, key) => {\n    result[key] = true\n    return result\n  },\n  {}\n)\n\nfunction ReactFinalForm<FormValues: FormValuesShape>({\n  debug,\n  decorators,\n  destroyOnUnregister,\n  form: alternateFormApi,\n  initialValues,\n  initialValuesEqual,\n  keepDirtyOnReinitialize,\n  mutators,\n  onSubmit,\n  subscription = all,\n  validate,\n  validateOnBlur,\n  ...rest\n}: Props<FormValues>) {\n  const config: Config<FormValues> = {\n    debug,\n    destroyOnUnregister,\n    initialValues,\n    keepDirtyOnReinitialize,\n    mutators,\n    onSubmit,\n    validate,\n    validateOnBlur\n  }\n\n  const form: FormApi<FormValues> = useConstant(() => {\n    const f = alternateFormApi || createForm<FormValues>(config)\n    // pause validation until children register all fields on first render (unpaused in useEffect() below)\n    f.pauseValidation()\n    return f\n  })\n\n  // synchronously register and unregister to query form state for our subscription on first render\n  const [state, setState] = React.useState<FormState<FormValues>>(\n    (): FormState<FormValues> => {\n      let initialState: FormState<FormValues> = {}\n      form.subscribe(state => {\n        initialState = state\n      }, subscription)()\n      return initialState\n    }\n  )\n\n  // save a copy of state that can break through the closure\n  // on the shallowEqual() line below.\n  const stateRef = useLatest<FormState<FormValues>>(state)\n\n  React.useEffect(() => {\n    // We have rendered, so all fields are now registered, so we can unpause validation\n    form.isValidationPaused() && form.resumeValidation()\n    const unsubscriptions: Unsubscribe[] = [\n      form.subscribe(s => {\n        if (!shallowEqual(s, stateRef.current)) {\n          setState(s)\n        }\n      }, subscription),\n      ...(decorators\n        ? decorators.map(decorator =>\n            // this noop ternary is to appease the flow gods\n            // istanbul ignore next\n            decorator(form)\n          )\n        : [])\n    ]\n\n    return () => {\n      form.pauseValidation() // pause validation so we don't revalidate on every field deregistration\n      unsubscriptions.reverse().forEach(unsubscribe => unsubscribe())\n      // don't need to resume validation here; either unmounting, or will re-run this hook with new deps\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [decorators])\n\n  // warn about decorator changes\n  // istanbul ignore next\n  if (process.env.NODE_ENV !== 'production') {\n    // You're never supposed to use hooks inside a conditional, but in this\n    // case we can be certain that you're not going to be changing your\n    // NODE_ENV between renders, so this is safe.\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useWhenValueChanges(\n      decorators,\n      () => {\n        console.error(\n          'Form decorators should not change from one render to the next as new values will be ignored'\n        )\n      },\n      shallowEqual\n    )\n  }\n\n  // allow updatable config\n  useWhenValueChanges(debug, () => {\n    form.setConfig('debug', debug)\n  })\n  useWhenValueChanges(destroyOnUnregister, () => {\n    form.destroyOnUnregister = !!destroyOnUnregister\n  })\n  useWhenValueChanges(keepDirtyOnReinitialize, () => {\n    form.setConfig('keepDirtyOnReinitialize', keepDirtyOnReinitialize)\n  })\n  useWhenValueChanges(\n    initialValues,\n    () => {\n      form.setConfig('initialValues', initialValues)\n    },\n    initialValuesEqual || shallowEqual\n  )\n  useWhenValueChanges(mutators, () => {\n    form.setConfig('mutators', mutators)\n  })\n  useWhenValueChanges(onSubmit, () => {\n    form.setConfig('onSubmit', onSubmit)\n  })\n  useWhenValueChanges(validate, () => {\n    form.setConfig('validate', validate)\n  })\n  useWhenValueChanges(validateOnBlur, () => {\n    form.setConfig('validateOnBlur', validateOnBlur)\n  })\n\n  const handleSubmit = (event: ?SubmitEvent) => {\n    if (event) {\n      // sometimes not true, e.g. React Native\n      if (typeof event.preventDefault === 'function') {\n        event.preventDefault()\n      }\n      if (typeof event.stopPropagation === 'function') {\n        // prevent any outer forms from receiving the event too\n        event.stopPropagation()\n      }\n    }\n    return form.submit()\n  }\n\n  const renderProps: FormRenderProps<FormValues> = {\n    form: {\n      ...form,\n      reset: eventOrValues => {\n        if (isSyntheticEvent(eventOrValues)) {\n          // it's a React SyntheticEvent, call reset with no arguments\n          form.reset()\n        } else {\n          form.reset(eventOrValues)\n        }\n      }\n    },\n    handleSubmit\n  }\n  addLazyFormState(renderProps, state)\n  return React.createElement(\n    ReactFinalFormContext.Provider,\n    { value: form },\n    renderComponent(\n      {\n        ...rest,\n        __versions: versions\n      },\n      renderProps,\n      'ReactFinalForm'\n    )\n  )\n}\n\nexport default ReactFinalForm\n","// @flow\nimport React from 'react'\n\n/**\n * A simple hook to create a constant value that lives for\n * the lifetime of the component.\n *\n * Plagiarized from https://github.com/Andarist/use-constant\n *\n * Do NOT reuse this code unless you know what you're doing.\n * Use Andarist's hook; it's more fault tolerant to things like\n * falsy values.\n *\n * @param {Function} init - A function to generate the value\n */\nexport default function useConstant<T>(init: () => T): T {\n  const ref = React.useRef<?T>()\n  if (!ref.current) {\n    ref.current = init()\n  }\n  return ref.current\n}\n","// @flow\nimport * as React from 'react'\nimport type { FormApi, FormValuesShape } from 'final-form'\nimport ReactFinalFormContext from './context'\n\nfunction useForm<FormValues: FormValuesShape>(\n  componentName?: string\n): FormApi<FormValues> {\n  const form: ?FormApi<FormValues> = React.useContext(ReactFinalFormContext)\n  if (!form) {\n    throw new Error(\n      `${componentName || 'useForm'} must be used inside of a <Form> component`\n    )\n  }\n  return form\n}\n\nexport default useForm\n","// @flow\nimport * as React from 'react'\nimport type { UseFormStateParams } from './types'\nimport type { FormState, FormApi, FormValuesShape } from 'final-form'\nimport { all } from './ReactFinalForm'\nimport useForm from './useForm'\nimport { addLazyFormState } from './getters'\n\nfunction useFormState<FormValues: FormValuesShape>({\n  onChange,\n  subscription = all\n}: UseFormStateParams<FormValues> = {}): FormState<FormValues> {\n  const form: FormApi<FormValues> = useForm<FormValues>('useFormState')\n  const firstRender = React.useRef(true)\n  const onChangeRef = React.useRef(onChange)\n  onChangeRef.current = onChange\n\n  // synchronously register and unregister to query field state for our subscription on first render\n  const [state, setState] = React.useState<FormState<FormValues>>(\n    (): FormState<FormValues> => {\n      let initialState: FormState<FormValues> = {}\n      form.subscribe(state => {\n        initialState = state\n      }, subscription)()\n      if (onChange) {\n        onChange(initialState)\n      }\n      return initialState\n    }\n  )\n\n  React.useEffect(\n    () =>\n      form.subscribe(newState => {\n        if (firstRender.current) {\n          firstRender.current = false\n        } else {\n          setState(newState)\n          if (onChangeRef.current) {\n            onChangeRef.current(newState)\n          }\n        }\n      }, subscription),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  )\n  const lazyState = {}\n  addLazyFormState(lazyState, state)\n  return lazyState\n}\n\nexport default useFormState\n","// @flow\nimport renderComponent from './renderComponent'\nimport type { FormSpyPropsWithForm as Props, FormSpyRenderProps } from './types'\nimport type { FormValuesShape } from 'final-form'\nimport isSyntheticEvent from './isSyntheticEvent'\nimport useForm from './useForm'\nimport useFormState from './useFormState'\n\nfunction FormSpy<FormValues: FormValuesShape>({\n  onChange,\n  subscription,\n  ...rest\n}: Props<FormValues>) {\n  const reactFinalForm = useForm<FormValues>('FormSpy')\n  const state = useFormState({ onChange, subscription })\n  if (onChange) {\n    return null\n  }\n\n  const renderProps: FormSpyRenderProps<FormValues> = {\n    form: {\n      ...reactFinalForm,\n      reset: eventOrValues => {\n        if (isSyntheticEvent(eventOrValues)) {\n          // it's a React SyntheticEvent, call reset with no arguments\n          reactFinalForm.reset()\n        } else {\n          reactFinalForm.reset(eventOrValues)\n        }\n      }\n    }\n  }\n  return renderComponent(\n    {\n      ...rest,\n      ...renderProps\n    },\n    state,\n    'FormSpy'\n  )\n}\n\nexport default FormSpy\n","// @flow\nimport * as React from 'react'\nimport { fieldSubscriptionItems } from 'final-form'\nimport type {\n  FieldSubscription,\n  FieldState,\n  FormApi,\n  FormValuesShape\n} from 'final-form'\nimport type { UseFieldConfig, FieldInputProps, FieldRenderProps } from './types'\nimport isReactNative from './isReactNative'\nimport getValue from './getValue'\nimport useForm from './useForm'\nimport useLatest from './useLatest'\nimport { addLazyFieldMetaState } from './getters'\n\nconst all: FieldSubscription = fieldSubscriptionItems.reduce((result, key) => {\n  result[key] = true\n  return result\n}, {})\n\nconst defaultFormat = (value: ?any, name: string) =>\n  value === undefined ? '' : value\nconst defaultParse = (value: ?any, name: string) =>\n  value === '' ? undefined : value\n\nconst defaultIsEqual = (a: any, b: any): boolean => a === b\n\nfunction useField<FormValues: FormValuesShape>(\n  name: string,\n  config: UseFieldConfig = {}\n): FieldRenderProps {\n  const {\n    afterSubmit,\n    allowNull,\n    component,\n    data,\n    defaultValue,\n    format = defaultFormat,\n    formatOnBlur,\n    initialValue,\n    multiple,\n    parse = defaultParse,\n    subscription = all,\n    type,\n    validateFields,\n    value: _value\n  } = config\n  const form: FormApi<FormValues> = useForm<FormValues>('useField')\n\n  const configRef = useLatest(config)\n\n  const register = (callback: FieldState => void, silent: boolean) =>\n    // avoid using `state` const in any closures created inside `register`\n    // because they would refer `state` from current execution context\n    // whereas actual `state` would defined in the subsequent `useField` hook\n    // execution\n    // (that would be caused by `setState` call performed in `register` callback)\n    form.registerField(name, callback, subscription, {\n      afterSubmit,\n      beforeSubmit: () => {\n        const {\n          beforeSubmit,\n          formatOnBlur,\n          format = defaultFormat\n        } = configRef.current\n\n        if (formatOnBlur) {\n          const { value } = ((form.getFieldState(name): any): FieldState)\n          const formatted = format(value, name)\n\n          if (formatted !== value) {\n            form.change(name, formatted)\n          }\n        }\n\n        return beforeSubmit && beforeSubmit()\n      },\n      data,\n      defaultValue,\n      getValidator: () => configRef.current.validate,\n      initialValue,\n      isEqual: (a, b) => (configRef.current.isEqual || defaultIsEqual)(a, b),\n      silent,\n      validateFields\n    })\n\n  const firstRender = React.useRef(true)\n\n  // synchronously register and unregister to query field state for our subscription on first render\n  const [state, setState] = React.useState<FieldState>((): FieldState => {\n    let initialState: FieldState = {}\n\n    // temporarily disable destroyOnUnregister\n    const destroyOnUnregister = form.destroyOnUnregister\n    form.destroyOnUnregister = false\n\n    register(state => {\n      initialState = state\n    }, true)()\n\n    // return destroyOnUnregister to its original value\n    form.destroyOnUnregister = destroyOnUnregister\n\n    return initialState\n  })\n\n  React.useEffect(\n    () =>\n      register(state => {\n        if (firstRender.current) {\n          firstRender.current = false\n        } else {\n          setState(state)\n        }\n      }, false),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      name,\n      data,\n      defaultValue,\n      // If we want to allow inline fat-arrow field-level validation functions, we\n      // cannot reregister field every time validate function !==.\n      // validate,\n      initialValue\n      // The validateFields array is often passed as validateFields={[]}, creating\n      // a !== new array every time. If it needs to be changed, a rerender/reregister\n      // can be forced by changing the key prop\n      // validateFields\n    ]\n  )\n\n  const handlers = {\n    onBlur: React.useCallback(\n      (event: ?SyntheticFocusEvent<*>) => {\n        state.blur()\n        if (formatOnBlur) {\n          /**\n           * Here we must fetch the value directly from Final Form because we cannot\n           * trust that our `state` closure has the most recent value. This is a problem\n           * if-and-only-if the library consumer has called `onChange()` immediately\n           * before calling `onBlur()`, but before the field has had a chance to receive\n           * the value update from Final Form.\n           */\n          const fieldState: any = form.getFieldState(state.name)\n          state.change(format(fieldState.value, state.name))\n        }\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [state.blur, state.name, format, formatOnBlur]\n    ),\n    onChange: React.useCallback(\n      (event: SyntheticInputEvent<*> | any) => {\n        // istanbul ignore next\n        if (process.env.NODE_ENV !== 'production' && event && event.target) {\n          const targetType = event.target.type\n          const unknown =\n            ~['checkbox', 'radio', 'select-multiple'].indexOf(targetType) &&\n            !type &&\n            component !== 'select'\n\n          const value: any =\n            targetType === 'select-multiple' ? state.value : _value\n\n          if (unknown) {\n            console.error(\n              `You must pass \\`type=\"${\n                targetType === 'select-multiple' ? 'select' : targetType\n              }\"\\` prop to your Field(${name}) component.\\n` +\n                `Without it we don't know how to unpack your \\`value\\` prop - ${\n                  Array.isArray(value) ? `[${value}]` : `\"${value}\"`\n                }.`\n            )\n          }\n        }\n\n        const value: any =\n          event && event.target\n            ? getValue(event, state.value, _value, isReactNative)\n            : event\n        state.change(parse(value, name))\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [_value, name, parse, state.change, state.value, type]\n    ),\n    onFocus: React.useCallback(\n      (event: ?SyntheticFocusEvent<*>) => {\n        state.focus()\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [state.focus]\n    )\n  }\n\n  const meta = {}\n  addLazyFieldMetaState(meta, state)\n  const input: FieldInputProps = {\n    name,\n    get value() {\n      let value = state.value\n      if (formatOnBlur) {\n        if (component === 'input') {\n          value = defaultFormat(value, name)\n        }\n      } else {\n        value = format(value, name)\n      }\n      if (value === null && !allowNull) {\n        value = ''\n      }\n      if (type === 'checkbox' || type === 'radio') {\n        return _value\n      } else if (component === 'select' && multiple) {\n        return value || []\n      }\n      return value\n    },\n    get checked() {\n      let value = state.value;\n      if (type === 'checkbox') {\n        value = format(value, name)\n        if (_value === undefined) {\n          return !!value\n        } else {\n          return !!(Array.isArray(value) && ~value.indexOf(_value))\n        }\n      } else if (type === 'radio') {\n        return format(value, name) === _value\n      }\n      return undefined\n    },\n    ...handlers\n  }\n\n  if (multiple) {\n    input.multiple = multiple\n  }\n  if (type !== undefined) {\n    input.type = type\n  }\n\n  const renderProps: FieldRenderProps = { input, meta } // assign to force Flow check\n  return renderProps\n}\n\nexport default useField\n","// @flow\nconst isReactNative =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.product &&\n  window.navigator.product === 'ReactNative'\n\nexport default isReactNative\n","// @flow\nconst getSelectedValues = options => {\n  const result = []\n  if (options) {\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index]\n      if (option.selected) {\n        result.push(option.value)\n      }\n    }\n  }\n  return result\n}\n\nconst getValue = (\n  event: SyntheticInputEvent<*>,\n  currentValue: any,\n  valueProp: any,\n  isReactNative: boolean\n) => {\n  if (\n    !isReactNative &&\n    event.nativeEvent &&\n    (event.nativeEvent: Object).text !== undefined\n  ) {\n    return (event.nativeEvent: Object).text\n  }\n  if (isReactNative && event.nativeEvent) {\n    return (event.nativeEvent: any).text\n  }\n  const detypedEvent: any = event\n  const { target: { type, value, checked } } = detypedEvent\n  switch (type) {\n    case 'checkbox':\n      if (valueProp !== undefined) {\n        // we are maintaining an array, not just a boolean\n        if (checked) {\n          // add value to current array value\n          return Array.isArray(currentValue)\n            ? currentValue.concat(valueProp)\n            : [valueProp]\n        } else {\n          // remove value from current array value\n          if (!Array.isArray(currentValue)) {\n            return currentValue\n          }\n          const index = currentValue.indexOf(valueProp)\n          if (index < 0) {\n            return currentValue\n          } else {\n            return currentValue\n              .slice(0, index)\n              .concat(currentValue.slice(index + 1))\n          }\n        }\n      } else {\n        // it's just a boolean\n        return !!checked\n      }\n    case 'select-multiple':\n      return getSelectedValues((event.target: any).options)\n    default:\n      return value\n  }\n}\n\nexport default getValue\n","// @flow\nimport * as React from 'react'\nimport type { FieldProps as Props, FieldRenderProps } from './types'\nimport renderComponent from './renderComponent'\nimport useField from './useField'\n\nconst Field = React.forwardRef<any, Props>(function Field(\n  {\n    afterSubmit,\n    allowNull,\n    beforeSubmit,\n    children,\n    component,\n    data,\n    defaultValue,\n    format,\n    formatOnBlur,\n    initialValue,\n    isEqual,\n    multiple,\n    name,\n    parse,\n    subscription,\n    type,\n    validate,\n    validateFields,\n    value,\n    ...rest\n  }: Props,\n  ref\n) {\n  const field: FieldRenderProps = useField(name, {\n    afterSubmit,\n    allowNull,\n    beforeSubmit,\n    children,\n    component,\n    data,\n    defaultValue,\n    format,\n    formatOnBlur,\n    initialValue,\n    isEqual,\n    multiple,\n    parse,\n    subscription,\n    type,\n    validate,\n    validateFields,\n    value\n  })\n\n  if (typeof children === 'function') {\n    return (children: Function)({ ...field, ...rest })\n  }\n\n  if (typeof component === 'string') {\n    // ignore meta, combine input with any other props\n    return React.createElement(component, {\n      ...field.input,\n      children,\n      ref,\n      ...rest\n    })\n  }\n\n  if (!name) {\n    throw new Error('prop name cannot be undefined in <Field> component')\n  }\n\n  return renderComponent(\n    { children, component, ref, ...rest },\n    field,\n    `Field(${name})`\n  )\n})\n\nexport default Field\n","// @flow\nimport Form from './ReactFinalForm'\nimport FormSpy from './FormSpy'\nexport { default as Field } from './Field'\nexport { default as Form, version } from './ReactFinalForm'\nexport { default as FormSpy } from './FormSpy'\nexport { default as useField } from './useField'\nexport { default as useFormState } from './useFormState'\nexport { default as useForm } from './useForm'\nexport function withTypes() {\n  return { Form, FormSpy }\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","key","source","prototype","hasOwnProperty","call","apply","this","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","renderComponent","props","lazyProps","name","render","children","component","rest","React","undefined","Error","useWhenValueChanges","value","callback","isEqual","a","b","previous","useRef","useEffect","current","shallowEqual","keysA","keysB","bHasOwnProperty","bind","idx","isSyntheticEvent","candidate","stopPropagation","useLatest","ref","addLazyState","dest","state","forEach","defineProperty","get","enumerable","addLazyFormState","versions","ffVersion","version","all","formSubscriptionItems","reduce","result","ReactFinalForm","debug","decorators","destroyOnUnregister","alternateFormApi","form","initialValues","initialValuesEqual","keepDirtyOnReinitialize","mutators","onSubmit","subscription","validate","validateOnBlur","config","init","f","createForm","pauseValidation","initialState","subscribe","setState","stateRef","isValidationPaused","resumeValidation","unsubscriptions","s","map","decorator","reverse","unsubscribe","setConfig","renderProps","reset","eventOrValues","handleSubmit","event","preventDefault","submit","ReactFinalFormContext","Provider","__versions","useForm","componentName","useFormState","onChange","firstRender","onChangeRef","newState","lazyState","FormSpy","reactFinalForm","defaultFormat","defaultParse","isReactNative","window","navigator","product","fieldSubscriptionItems","useField","register","silent","registerField","afterSubmit","beforeSubmit","configRef","formatOnBlur","format","formatted","getFieldState","change","data","defaultValue","getValidator","initialValue","validateFields","allowNull","multiple","parse","type","_value","handlers","onBlur","fieldState","blur","currentValue","valueProp","nativeEvent","text","checked","Array","isArray","concat","index","slice","options","option","selected","push","getSelectedValues","getValue","onFocus","focus","meta","input","Field","field","Form"],"mappings":"iaAAe,SAASA,IAetB,OAdAA,EAAWC,OAAOC,QAAU,SAAUC,GACpC,IAAK,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CACzC,IAESG,EAFLC,EAASH,UAAUD,GAEvB,IAASG,KAAOC,EACVP,OAAOQ,UAAUC,eAAeC,KAAKH,EAAQD,KAC/CJ,EAAOI,GAAOC,EAAOD,IAK3B,OAAOJ,IAGOS,MAAMC,KAAMR,WCff,SAASS,EAA8BN,EAAQO,GAC5D,GAAc,MAAVP,EAAgB,MAAO,GAK3B,IAJA,IAEID,EAFAJ,EAAS,GACTa,EAAaf,OAAOgB,KAAKT,GAGxBJ,EAAI,EAAGA,EAAIY,EAAWV,OAAQF,IACjCG,EAAMS,EAAWZ,GACY,GAAzBW,EAASG,QAAQX,KACrBJ,EAAOI,GAAOC,EAAOD,IAGvB,OAAOJ,ECNM,SAASgB,EACtBC,EACAC,EACAC,OAEQC,EAAyCH,EAAzCG,OAAQC,EAAiCJ,EAAjCI,SAAUC,EAAuBL,EAAvBK,UAAcC,IAASN,wCAC7CK,SACKE,gBACLF,EACAxB,OAAOC,OAAOmB,EAAWK,EAAM,CAC7BF,SAAAA,EACAD,OAAAA,QAIFA,SACKA,OACQK,IAAbJ,EACIvB,OAAOC,OAAOmB,EAAWK,GAEzBzB,OAAOC,OAAOmB,EAAWK,EAAM,CAAEF,SAAAA,QAGjB,mBAAbA,QACH,IAAIK,kGACoFP,UAGzFE,EAASvB,OAAOC,OAAOmB,EAAWK,IC/B5B,SAASI,EACtBC,EACAC,EACAC,YAAAA,IAAAA,EAAiC,SAACC,EAAGC,UAAMD,IAAMC,QAE3CC,EAAWT,UAAMU,OAAON,GAC9BJ,UAAMW,UAAU,WACTL,EAAQF,EAAOK,EAASG,WAC3BP,IACAI,EAASG,QAAUR,KCXzB,IAAMS,EAAe,SAACN,EAAQC,MACxBD,IAAMC,SACD,KAEQ,iBAAND,IAAmBA,GAAkB,iBAANC,IAAmBA,SACpD,MAELM,EAAQxC,OAAOgB,KAAKiB,GACpBQ,EAAQzC,OAAOgB,KAAKkB,MACpBM,EAAMnC,SAAWoC,EAAMpC,cAClB,UAELqC,EAAkB1C,OAAOQ,UAAUC,eAAekC,KAAKT,GAClDU,EAAM,EAAGA,EAAMJ,EAAMnC,OAAQuC,IAAO,KACvCtC,EAAMkC,EAAMI,OACXF,EAAgBpC,IAAQ2B,EAAE3B,KAAS4B,EAAE5B,UACjC,SAGJ,GCnBHuC,EAAmB,SAACC,YACrBA,GAAkD,mBAA9BA,EAAUC,oBCEpBrB,kBCDA,SAASsB,EAAalB,OAC7BmB,EAAMvB,UAAMU,OAAON,UAEzBJ,UAAMW,UAAU,WACdY,EAAIX,QAAUR,IAGTmB,ECRY,SAAfC,EAAgBC,EAAcC,EAAepC,GACjDA,EAAKqC,QAAQ,SAAA/C,GACXN,OAAOsD,eAAeH,EAAM7C,EAAK,CAC/BiD,IAAK,kBAAMH,EAAM9C,IACjBkD,YAAY,oBAKLC,EAAmB,SAACN,EAAcC,UAC7CF,EAAaC,EAAMC,EAAO,CACxB,SACA,QACA,cACA,uBACA,6BACA,QACA,SACA,kBACA,sBACA,gBACA,UACA,WACA,0BACA,WACA,cACA,eACA,eACA,kBACA,aACA,UACA,QACA,aACA,SACA,aCPEM,EAAW,cACDC,6BACMC,GAGTC,EAAwBC,wBAAsBC,OACzD,SAACC,EAAQ1D,UACP0D,EAAO1D,IAAO,EACP0D,GAET,IAGF,SAASC,SACPC,IAAAA,MACAC,IAAAA,WACAC,IAAAA,oBACMC,IAANC,KACAC,IAAAA,cACAC,IAAAA,mBACAC,IAAAA,wBACAC,IAAAA,SACAC,IAAAA,aACAC,aAAAA,aAAef,IACfgB,IAAAA,SACAC,IAAAA,eACGrD,2LAEGsD,EAA6B,CACjCb,MAAAA,EACAE,oBAAAA,EACAG,cAAAA,EACAE,wBAAAA,EACAC,SAAAA,EACAC,SAAAA,EACAE,SAAAA,EACAC,eAAAA,GAGIR,GCrD+BU,EDqDS,eACtCC,EAAIZ,GAAoBa,aAAuBH,UAErDE,EAAEE,kBACKF,ICxDHhC,EAAMvB,UAAMU,UACTE,UACPW,EAAIX,QAAU0C,KAET/B,EAAIX,WDwDeZ,WACxB,eACM0D,EAAsC,UAC1Cd,EAAKe,UAAU,SAAAjC,GACbgC,EAAehC,GACdwB,EAFHN,GAGOc,IANJhC,OAAOkC,OAYRC,EAAWvC,EAAiCI,GAElD1B,YAAgB,WAEd4C,EAAKkB,sBAAwBlB,EAAKmB,uBAC5BC,GACJpB,EAAKe,UAAU,SAAAM,GACRpD,EAAaoD,EAAGJ,EAASjD,UAC5BgD,EAASK,IAEVf,WACCT,EACAA,EAAWyB,IAAI,SAAAC,UAGbA,EAAUvB,KAEZ,WAGC,WACLA,EAAKa,kBACLO,EAAgBI,UAAUzC,QAAQ,SAAA0C,UAAeA,QAIlD,CAAC5B,IAsBJtC,EAAoBqC,EAAO,WACzBI,EAAK0B,UAAU,QAAS9B,KAE1BrC,EAAoBuC,EAAqB,WACvCE,EAAKF,sBAAwBA,IAE/BvC,EAAoB4C,EAAyB,WAC3CH,EAAK0B,UAAU,0BAA2BvB,KAE5C5C,EACE0C,EACA,WACED,EAAK0B,UAAU,gBAAiBzB,IAElCC,GAAsBjC,GAExBV,EAAoB6C,EAAU,WAC5BJ,EAAK0B,UAAU,WAAYtB,KAE7B7C,EAAoB8C,EAAU,WAC5BL,EAAK0B,UAAU,WAAYrB,KAE7B9C,EAAoBgD,EAAU,WAC5BP,EAAK0B,UAAU,WAAYnB,KAE7BhD,EAAoBiD,EAAgB,WAClCR,EAAK0B,UAAU,iBAAkBlB,KAiB7BmB,EAA2C,CAC/C3B,UACKA,GACH4B,MAAO,SAAAC,GACDtD,EAAiBsD,GAEnB7B,EAAK4B,QAEL5B,EAAK4B,MAAMC,MAIjBC,aA1BmB,SAACC,UAChBA,IAEkC,mBAAzBA,EAAMC,gBACfD,EAAMC,iBAE6B,mBAA1BD,EAAMtD,iBAEfsD,EAAMtD,mBAGHuB,EAAKiC,kBAiBd9C,EAAiBwC,EAAa7C,GACvB1B,gBACL8E,EAAsBC,SACtB,CAAE3E,MAAOwC,GACTpD,OAEOO,GACHiF,WAAYhD,IAEduC,EACA,mBEtMN,SAASU,EACPC,OAEMtC,EAA6B5C,aAAiB8E,OAC/ClC,QACG,IAAI1C,OACLgF,GAAiB,gEAGjBtC,ECNT,SAASuC,sBAG2B,KAFlCC,IAAAA,aACAlC,aAAAA,aAAef,IAETS,EAA4BqC,EAAoB,gBAChDI,EAAcrF,UAAa,GAC3BsF,EAActF,SAAaoF,GACjCE,EAAY1E,QAAUwE,QAGIpF,WACxB,eACM0D,EAAsC,UAC1Cd,EAAKe,UAAU,SAAAjC,GACbgC,EAAehC,GACdwB,EAFHN,GAGIwC,GACFA,EAAS1B,GAEJA,IATJhC,OAAOkC,OAad5D,YACE,kBACE4C,EAAKe,UAAU,SAAA4B,GACTF,EAAYzE,QACdyE,EAAYzE,SAAU,GAEtBgD,EAAS2B,GACLD,EAAY1E,SACd0E,EAAY1E,QAAQ2E,KAGvBrC,QAIDsC,EAAY,UAClBzD,EAAiByD,EAAW9D,GACrB8D,ECxCT,SAASC,SACPL,IAAAA,SACAlC,IAAAA,aACGnD,mCAEG2F,EAAiBT,EAAoB,WACrCvD,EAAQyD,EAAa,CAAEC,SAAAA,EAAUlC,aAAAA,OACnCkC,SACK,KAGHb,EAA8C,CAClD3B,UACK8C,GACHlB,MAAO,SAAAC,GACDtD,EAAiBsD,GAEnBiB,EAAelB,QAEfkB,EAAelB,MAAMC,cAKtBjF,OAEAO,EACAwE,GAEL7C,EACA,WCjBkB,SAAhBiE,EAAiBvF,eACXH,IAAVG,EAAsB,GAAKA,EACR,SAAfwF,EAAgBxF,SACV,KAAVA,OAAeH,EAAYG,ECvB7B,IAAMyF,EACc,oBAAXC,QACPA,OAAOC,WACPD,OAAOC,UAAUC,SACY,gBAA7BF,OAAOC,UAAUC,QDWb7D,EAAyB8D,yBAAuB5D,OAAO,SAACC,EAAQ1D,UACpE0D,EAAO1D,IAAO,EACP0D,GACN,IASH,SAAS4D,EACPvG,EACA0D,YAAAA,IAAAA,EAAyB,IAsBR,SAAX8C,EAAY9F,EAA8B+F,UAM9CxD,EAAKyD,cAAc1G,EAAMU,EAAU6C,EAAc,CAC/CoD,YAAAA,EACAC,aAAc,iBAKRC,EAAU5F,QAHZ2F,IAAAA,aACAE,IAAAA,iBACAC,cAGED,IAEIE,cALGhB,KAIDvF,EAAYwC,EAAKgE,cAAcjH,GAA/BS,MACwBT,MAEdS,GAChBwC,EAAKiE,OAAOlH,EAAMgH,GAIfJ,GAAgBA,KAEzBO,KAAAA,EACAC,aAAAA,EACAC,aAAc,kBAAMR,EAAU5F,QAAQuC,UACtC8D,aAAAA,EACA3G,QAAS,SAACC,EAAGC,UAAOgG,EAAU5F,QAAQN,SAxDrB,SAACC,EAAQC,UAAoBD,IAAMC,IAwDaD,EAAGC,IACpE4F,OAAAA,EACAc,eAAAA,QAnDFZ,EAcEjD,EAdFiD,YACAa,EAaE9D,EAbF8D,UACArH,EAYEuD,EAZFvD,UACAgH,EAWEzD,EAXFyD,KACAC,EAUE1D,EAVF0D,eAUE1D,EATFqD,OAAAA,aAASf,IACTc,EAQEpD,EARFoD,aACAQ,EAOE5D,EAPF4D,aACAG,EAME/D,EANF+D,WAME/D,EALFgE,MAAAA,aAAQzB,MAKNvC,EAJFH,aAAAA,aAAef,IACfmF,EAGEjE,EAHFiE,KACAJ,EAEE7D,EAFF6D,eACOK,EACLlE,EADFjD,MAEIwC,EAA4BqC,EAAoB,YAEhDuB,EAAYlF,EAAU+B,GAqCtBgC,EAAcrF,UAAa,KAGPA,WAA2B,eAC/C0D,EAA2B,GAGzBhB,EAAsBE,EAAKF,2BACjCE,EAAKF,qBAAsB,EAE3ByD,EAAS,SAAAzE,GACPgC,EAAehC,IACd,EAFHyE,GAKAvD,EAAKF,oBAAsBA,EAEpBgB,IAdFhC,OAAOkC,OAiBd5D,YACE,kBACEmG,EAAS,SAAAzE,GACH2D,EAAYzE,QACdyE,EAAYzE,SAAU,EAEtBgD,EAASlC,KAEV,KAGH/B,EACAmH,EACAC,EAIAE,IAQEO,EAAW,CACfC,OAAQzH,cACN,SAAC2E,OAUS+C,EATRhG,EAAMiG,OACFlB,IAQIiB,EAAkB9E,EAAKgE,cAAclF,EAAM/B,MACjD+B,EAAMmF,OAAOH,EAAOgB,EAAWtH,MAAOsB,EAAM/B,UAI/C+B,EAAMiG,KAAMjG,EAAM/B,KAAM+G,EAAQD,IAEnCrB,SAAUpF,cACR,SAAC2E,GAwBOvE,EACJuE,GAASA,EAAMnG,OEnKR,SACfmG,EACAiD,EACAC,EACAhC,OAGGA,GACDlB,EAAMmD,kBAC+B7H,IAApC0E,EAAMmD,YAAqBC,YAEpBpD,EAAMmD,YAAqBC,QAEjClC,GAAiBlB,EAAMmD,mBACjBnD,EAAMmD,YAAkBC,WAERpD,EAClBnG,OAAU8I,IAAAA,KAAMlH,IAAAA,MAAO4H,IAAAA,eACvBV,OACD,mBACerH,IAAd4H,UAuBOG,KArBLA,SAEKC,MAAMC,QAAQN,GACjBA,EAAaO,OAAON,GACpB,CAACA,OAGAI,MAAMC,QAAQN,UACVA,EAEHQ,EAAQR,EAAarI,QAAQsI,UAC/BO,EAAQ,EACHR,EAEAA,EACJS,MAAM,EAAGD,GACTD,OAAOP,EAAaS,MAAMD,EAAQ,QAOxC,yBA1DiB,SAAAE,OAClBhG,EAAS,MACXgG,MACG,IAAIF,EAAQ,EAAGA,EAAQE,EAAQ3J,OAAQyJ,IAAS,KAC7CG,EAASD,EAAQF,GACnBG,EAAOC,UACTlG,EAAOmG,KAAKF,EAAOnI,cAIlBkC,EAiDIoG,CAAmB/D,EAAMnG,OAAa8J,wBAEtClI,GFoHCuI,CAAShE,EAAOjD,EAAMtB,MAAOmH,EAAQ1B,GACrClB,EACNjD,EAAMmF,OAAOQ,EAAMjH,EAAOT,MAG3B4H,EAAQ5H,EAAM0H,EAAO3F,EAAMmF,OAAQnF,EAAMtB,MAAOkH,IAEnDsB,QAAS5I,cACP,SAAC2E,GACCjD,EAAMmH,UAGPnH,EAAMmH,SAILC,EAAO,GN1JbtH,EM2JsBsH,EAAMpH,EN3JF,CACxB,SACA,OACA,QACA,uBACA,QACA,UACA,UACA,SACA,WACA,0BACA,WACA,cACA,eACA,kBACA,aACA,UACA,QACA,aACA,YMyIIqH,KACJpJ,KAAAA,kBAEMS,EAAQsB,EAAMtB,aACdqG,EACgB,UAAd3G,IACFM,EAAQuF,EAAcvF,IAGxBA,EAAQsG,EAAOtG,EAAOT,GAEV,OAAVS,GAAmB+G,IACrB/G,EAAQ,IAEG,aAATkH,GAAgC,UAATA,EAClBC,EACgB,WAAdzH,GAA0BsH,EAC5BhH,GAAS,GAEXA,qBAGHA,EAAQsB,EAAMtB,YACL,aAATkH,GACFlH,EAAQsG,EAAOtG,EAAOT,QACPM,IAAXsH,IACOnH,KAEC6H,MAAMC,QAAQ9H,MAAWA,EAAMb,QAAQgI,KAEjC,UAATD,EACFZ,EAAOtG,EAAOT,KAAU4H,OAD1B,IAKNC,UAGDJ,IACF2B,EAAM3B,SAAWA,QAENnH,IAATqH,IACFyB,EAAMzB,KAAOA,GAGuB,CAAEyB,MAAAA,EAAOD,KAAAA,OG3O3CE,EAAQhJ,aAA6B,WAuBzCuB,OArBE+E,IAAAA,YACAa,IAAAA,UACAZ,IAAAA,aACA1G,IAAAA,SACAC,IAAAA,UACAgH,IAAAA,KACAC,IAAAA,aACAL,IAAAA,OACAD,IAAAA,aACAQ,IAAAA,aACA3G,IAAAA,QACA8G,IAAAA,SACAzH,IAAAA,KACA0H,IAAAA,MACAnE,IAAAA,aACAoE,IAAAA,KACAnE,IAAAA,SACA+D,IAAAA,eACA9G,IAAAA,MACGL,oOAICkJ,EAA0B/C,EAASvG,EAAM,CAC7C2G,YAAAA,EACAa,UAAAA,EACAZ,aAAAA,EACA1G,SAAAA,EACAC,UAAAA,EACAgH,KAAAA,EACAC,aAAAA,EACAL,OAAAA,EACAD,aAAAA,EACAQ,aAAAA,EACA3G,QAAAA,EACA8G,SAAAA,EACAC,MAAAA,EACAnE,aAAAA,EACAoE,KAAAA,EACAnE,SAAAA,EACA+D,eAAAA,EACA9G,MAAAA,OAGsB,mBAAbP,SACDA,OAAyBoJ,EAAUlJ,OAGpB,iBAAdD,SAEFE,gBAAoBF,OACtBmJ,EAAMF,OACTlJ,SAAAA,EACA0B,IAAAA,GACGxB,QAIFJ,QACG,IAAIO,MAAM,6DAGXV,KACHK,SAAAA,EAAUC,UAAAA,EAAWyB,IAAAA,GAAQxB,GAC/BkJ,WACStJ,0GChEN,iBACE,CAAEuJ,KAAAA,EAAMzD,QAAAA"}